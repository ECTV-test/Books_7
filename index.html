<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Book Reader Prototype</title>

  <style>
    :root{
      /* Main background (day) */
      --bg:#F5F3EE;
      --card:#ffffff;
      --text:#121826;
      --muted:#667085;
      --line:#e6e8ef;
      --primary:#1e88e5;
      --primary2:#2aa7ff;
      --shadow:0 10px 28px rgba(16,24,40,.10);
      --radius:18px;
      /* BiReader background should match Listen mode (use the main app bg) */
      --readerBg:var(--bg);
      --underline: rgba(18,24,38,.35);

      /* highlight theme defaults (blue) */
      --hlWord: rgba(42,167,255,.26);

      --fontSize: 22px;
      --lineHeight: 1.9;

      --safeBottom: env(safe-area-inset-bottom);
    }

    [data-theme="night"]{
      --bg:#0b1220;
      --card:#0f1a2f;
      --text:#e8ecf5;
      --muted:#a8b3c7;
      --line:rgba(255,255,255,.10);
      --shadow:0 10px 28px rgba(0,0,0,.45);
      --readerBg:#0b1220;
      --underline: rgba(232,236,245,.28);
      --hlWord: rgba(42,167,255,.22);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:var(--bg);
      color:var(--text);
    }
    a{color:inherit;text-decoration:none}
    button, select{font:inherit}
    .wrap{max-width:1120px;margin:0 auto;padding:24px 18px 86px}

    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:10px 0 18px;
    }
    .brand{
      display:flex;align-items:center;gap:12px;
      font-weight:800;letter-spacing:.2px;
      min-width:0;
    }
    .pill{
      font-size:12px;color:var(--muted);
      border:1px solid var(--line);
      padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.35);
      white-space:nowrap;
    }
    [data-theme="night"] .pill{background:rgba(255,255,255,.04)}
    .navbtn{
      display:inline-flex;align-items:center;gap:8px;
      border:1px solid var(--line);
      background:var(--card);
      padding:10px 12px;border-radius:12px;
      box-shadow:0 2px 10px rgba(16,24,40,.06);
      cursor:pointer;
      font-weight:800;
      white-space:nowrap;
    }
    .navbtn:active{transform:translateY(1px)}
    .brandTitle{
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:48vw;
    }

    .sectionRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;margin:10px 0 16px;
    }
    .sectionTitle{font-size:20px;font-weight:900}
    .linkBtn{
      color:var(--primary);
      border:none;background:transparent;
      padding:8px 10px;border-radius:999px;
      cursor:pointer;
      font-weight:800;
      white-space:nowrap;
    }
    .linkBtn:hover{background:rgba(30,136,229,.08)}

    .grid{
      display:grid;
      grid-template-columns:repeat(6, minmax(0,1fr));
      gap:16px;
    }
    @media (max-width: 1100px){ .grid{grid-template-columns:repeat(3, minmax(0,1fr))} }
    @media (max-width: 640px){
      .grid{grid-template-columns:repeat(2, minmax(0,1fr))}
      .wrap{padding-bottom:110px}
      .brandTitle{max-width:44vw}
    }

    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      cursor:pointer;
      transition:transform .12s ease;
      min-height:220px;
    }
    .card:hover{transform:translateY(-2px)}
    .cover{
      width:100%;
      aspect-ratio: 1 / 1.05;
      background:linear-gradient(145deg, #f4c9a9, #f7efe7);
      position:relative;
    }
    .cover img{width:100%;height:100%;object-fit:cover;display:block}
    .badgeTop{
      position:absolute;left:12px;top:12px;
      font-size:12px;color:var(--muted);
      background:rgba(255,255,255,.78);
      border:1px solid rgba(0,0,0,.06);
      padding:6px 10px;border-radius:999px;
      backdrop-filter: blur(8px);
      max-width: calc(100% - 24px);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    [data-theme="night"] .badgeTop{
      background:rgba(15,26,47,.72);
      border-color:rgba(255,255,255,.10);
    }
    .cardBody{padding:12px 12px 14px}
    .small{font-size:12px;color:var(--muted);margin:0 0 6px}
    .title{font-size:15px;font-weight:900;margin:0;line-height:1.25}
    .metaLine{
      display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;
      color:var(--muted);font-size:12px;
    }
    .dot{width:6px;height:6px;border-radius:50%;background:#22c55e;display:inline-block;margin-right:6px}
    .metaItem{display:inline-flex;align-items:center;gap:6px}

    /* Details */
    .details{
      display:grid;
      grid-template-columns: 260px 1fr;
      gap:18px;
      align-items:start;
      margin-top:8px;
    }
    @media (max-width: 760px){ .details{grid-template-columns:1fr} }
    .bookPoster{
      border-radius:22px;
      overflow:hidden;
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      background:var(--card);
    }
    .bookPoster img{width:100%;display:block}
    .panel{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:22px;
      box-shadow:var(--shadow);
      padding:16px;
    }
    .kicker{font-size:12px;color:var(--muted);margin:0 0 6px}
    .bookName{font-size:26px;line-height:1.15;margin:0 0 10px;font-weight:950}
    .desc{color:var(--muted);line-height:1.55;margin:10px 0 14px}
    .infoRow{
      display:flex;gap:12px;flex-wrap:wrap;
      padding:10px 0 4px;color:var(--muted);font-size:13px
    }
    .infoRow b{color:var(--text)}
    .ctaRow{display:flex;gap:12px;flex-wrap:wrap;margin-top:10px}
    .btn{
      border:none;cursor:pointer;
      padding:12px 14px;border-radius:14px;
      font-weight:900;
      display:inline-flex;align-items:center;gap:10px;
      white-space:nowrap;
    }
    .btnPrimary{background:linear-gradient(135deg, var(--primary), var(--primary2));color:white}
    .btnGhost{background:transparent;border:1px solid var(--line);color:var(--text)}
    .btn:active{transform:translateY(1px)}

    /* Reader */
    .readerStage{
      background:var(--readerBg);
      min-height:calc(100vh - 0px);
      padding:14px 14px 118px;
    }
    /* BiReader top bar (match the new "Listen" style) */
    .readTopBar{
      max-width:860px;
      margin:0 auto 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      /* Keep header visible while scrolling (like the player) */
      position: sticky;
      top: 0;
      z-index: 20;
      background: var(--readerBg);
      padding: 10px 0;
    }
    .readTopBar .rtLeft,
    .readTopBar .rtRight{display:flex;align-items:center;gap:10px;min-width:0}
    .readTopBar .rtCenter{
      flex:1;min-width:0;
      text-align:center;
      font-weight:900;
      opacity:.75;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .paper{
      max-width:860px;margin:0 auto;
      padding:10px 0 60px;
      background:transparent;
      color:var(--text);
    }
    /* BiReader content should sit on the background without frames */
    .paperInner{
      background:transparent;
      border:none;
      border-radius:0;
      box-shadow:none;
      padding:0;
    }
    .bookTitle{
      text-align:center;
      font-weight:950;
      font-size:40px;
      margin:4px 0 18px;
      letter-spacing:.2px;
      font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
    }
    @media (max-width: 640px){
      .bookTitle{font-size:34px}
      .paperInner{padding:0}
    }
    .para{
      font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
      font-size: var(--fontSize);
      line-height: var(--lineHeight);
      margin: 0 0 18px;
    }

    .paraLine{ margin: 0 0 14px; }
    .line{
      font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
      font-size: calc(var(--fontSize) * 1.12); /* original a bit larger */
      line-height: var(--lineHeight);
      margin: 0;
    }
    .line.active{
      background: var(--hlWord);
      border-radius: 10px;
      padding: 2px 6px;
    }
        .paraTrans{
      margin-top: 6px;
      font-size: var(--fontSize); /* translation same size as previous original */
      line-height: 1.55;
      color: var(--muted);        /* lighter */
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    /* Hide translation line in BiReader */
    body.hideLineTrans .paraLine .paraTrans{display:none !important;}


    /* Active highlight colors are controlled via CSS variables:
       --hlLine (strong) and --hlLineSoft (lighter).
       They are set in applyHighlightTheme(). */
    .para.activeLine{
      background: var(--hlLine);
      border-radius: 14px;
      padding: 6px 8px;
    }
    .line.activeLine{
      background: var(--hlLine);
      border-radius: 14px;
      padding: 6px 8px;
      display:inline-block;
    }
    .paraTrans.activeTrans{
      background: var(--hlLineSoft);
      border-radius: 12px;
      padding: 6px 8px;
      color: var(--text);
    }

    /* Bi-reader highlight when swapLang is enabled (translation becomes strong line) */
    .paraTrans.activeLine{
      background: var(--hlLine);
      border-radius: 14px;
      padding: 6px 8px;
      color: var(--text);
    }
    .line.activeTrans{
      background: var(--hlLineSoft);
      border-radius: 12px;
      padding: 6px 8px;
      display:inline-block;
    }

    /* Bi-reader: when swapLang is enabled, show the spoken line on top */
    body.swapLang .paraLine{
      display:flex;
      flex-direction: column-reverse;
      gap: 6px;
    }

    .w{
      display:inline-block;
      padding:0 2px 2px;
      border-bottom: 2px solid var(--underline);
      user-select:none;
      border-radius:8px;
      cursor:pointer; /* —Ç–µ–ø–µ—Ä—å –ø–µ—Ä–µ–≤–æ–¥ –ø–æ –∫–ª–∏–∫—É */
    }
    .w.space{border-bottom-color:transparent;padding:0;cursor:default}
    .w.active{
      background: var(--hlWord);
      border-bottom-color: transparent;
    }


    /* Listen (Reader) new UI */
    body[data-route="reader"] .readerStage{padding-bottom:110px;}
    .listenStage{max-width:860px;margin:0 auto;padding:18px 18px calc(120px + var(--safeBottom));}
    .listenTop{
      display:flex;align-items:center;justify-content:space-between;
      gap:12px;
      /* Keep header visible while scrolling (like the player) */
      position: sticky;
      top: 0;
      z-index: 20;
      background: var(--readerBg);
      padding: 10px 0;
    }
    .listenTop .ltLeft{display:flex;align-items:center;gap:12px;min-width:0}
    .chevBtn{
      width:44px;height:44px;border-radius:14px;border:none;
      background:rgba(0,0,0,.06); color:var(--text);
      display:inline-flex;align-items:center;justify-content:center;
      cursor:pointer;
    }
    [data-theme="night"] .chevBtn{background:rgba(255,255,255,.10)}
    .ltCenter{flex:1;min-width:0;text-align:center;font-weight:900;opacity:.75}
    .ltRight{display:flex;align-items:center;gap:10px}
    .topIcon{
      width:44px;height:44px;border-radius:14px;border:none;
      background:rgba(0,0,0,.06); color:var(--text);
      display:inline-flex;align-items:center;justify-content:center;
      cursor:pointer;
    }
    [data-theme="night"] .topIcon{background:rgba(255,255,255,.10)}
    .listenTitle{
      font-size:44px;line-height:1.02;font-weight:980;
      margin:18px 6px 10px;
      letter-spacing:-0.6px;
    }
    .listenList{margin-top:10px;display:flex;flex-direction:column;gap:14px}
    .listenLine{
      display:flex;align-items:flex-start;gap:12px;
    }
    .listenLine .para{
      flex:1;margin:0;
      font-size:22px;line-height:1.55;
      padding:2px 0;
    }
    .lineCardBtn{
      width:36px;height:36px;border-radius:12px;border:none;
      background:rgba(0,0,0,.05);
      display:inline-flex;align-items:center;justify-content:center;
      cursor:pointer;flex:0 0 auto;margin-top:4px;
    }
    [data-theme="night"] .lineCardBtn{background:rgba(255,255,255,.09)}
    .lineCardBtn svg{width:18px;height:18px;opacity:.8}
    .listenLine.activeLine .para{background:var(--hlLine);border-radius:10px;padding:2px 6px}
    .listenLine.activeLine .paraTrans{background:var(--hlLineSoft);}

    /* Popover actions */
    .popActions{display:flex;gap:10px;justify-content:flex-end;margin-top:10px}
    .popPlay{
      border:none;cursor:pointer;
      padding:10px 12px;border-radius:14px;
      background:linear-gradient(135deg, var(--primary), var(--primary2));
      color:white;font-weight:950;
    }

    /* Mode switch (bottom right) */
    .modeSwitch{
      display:inline-flex;align-items:center;gap:8px;
      padding:6px;border-radius:18px;
      background:rgba(0,0,0,.06);
    }
    [data-theme="night"] .modeSwitch{background:rgba(255,255,255,.10)}
    .modeBtn{
      width:40px;height:40px;border-radius:14px;border:none;
      background:transparent;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;
      opacity:.55;
    }
    .modeBtn.active{background:rgba(0,0,0,.06);opacity:1}
    [data-theme="night"] .modeBtn.active{background:rgba(255,255,255,.10)}
    .modeBtn svg{width:20px;height:20px}


    /* Bottom player */
    .playerBar{
      position:fixed;left:0;right:0;bottom:0;
      background:rgba(255,255,255,.75);
      backdrop-filter: blur(10px);
      border-top:1px solid var(--line);
      padding:10px 14px calc(10px + var(--safeBottom));
      z-index:50;
    }
    [data-theme="night"] .playerBar{background:rgba(15,26,47,.70)}
    .playerInner{
      max-width:980px;margin:0 auto;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:12px;
      align-items:center;
    }
    @media (max-width: 520px){
      .playerInner{grid-template-columns:1fr}
      .controls{justify-content:space-between}
    }
    .progTop{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .progTitle{font-weight:950;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:60vw}
    .progMeta{color:var(--muted);font-size:12px;white-space:nowrap}
    .bar{
      height:10px;border-radius:999px;
      background:rgba(0,0,0,.08);
      overflow:hidden;
      margin-top:8px;
    }
    [data-theme="night"] .bar{background:rgba(255,255,255,.10)}
    .bar > div{
      height:100%;width:0%;
      background:linear-gradient(135deg, var(--primary), var(--primary2));
      border-radius:999px;
    }
    .controls{display:flex;gap:10px;align-items:center;justify-content:flex-end}
    .iconBtn{
  border:none;
  background: rgba(0,0,0,.06);
  width:44px;height:44px;border-radius:16px;
  display:inline-flex;align-items:center;justify-content:center;
  cursor:pointer;
  box-shadow:none;
  font-weight:950;
  color: rgba(0,0,0,.75);
}
    .iconBtn:active{transform:translateY(1px)}
    .playBtn{
      width:52px;height:52px;border-radius:16px;
      border:none;cursor:pointer;color:white;
      background:linear-gradient(135deg, var(--primary), var(--primary2));
      font-weight:950;
      display:inline-flex;align-items:center;justify-content:center;
    }

    /* Popover */
    .popover{
      position:fixed;
      min-width:260px;
      max-width:360px;
      background:#3570B8;
      border:none;
      box-shadow:0 2px 17.5px rgba(0,0,0,.07);
      border-radius:13px;
      padding:14px;
      z-index:60;
      display:none;
      color:#fff;
    }
    .popRow{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .popWord{font-weight:950;color:#fff}
    .popTrans{color:rgba(255,255,255,.9);margin-top:6px;line-height:1.35}
    .miniBtn{
      border:1px solid rgba(255,255,255,.35);
      background:rgba(255,255,255,.12);
      color:#fff;
      padding:7px 10px;border-radius:12px;
      cursor:pointer;
      font-weight:800;
      backdrop-filter:blur(6px);
    }
    .miniBtn:active{transform:scale(.98)}
    .loading{opacity:.8;font-style:italic}
    /* Sheets (bottom panels) */
    .sheetBackdrop{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(3px);
      z-index:65;
      display:none;
    }
    .sheet{
      position:fixed;
      left:14px;
      right:14px;
      bottom: calc(84px + var(--safeBottom));
      max-width: 560px;
      margin: 0 auto;
      background:var(--card);
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      border-radius: 26px;
      padding: 12px 12px 14px;
      z-index:70;
      display:none;
      transform: translateY(18px);
      opacity:0;
      transition: transform .18s ease, opacity .18s ease;
    }
    .sheet.open{
      transform: translateY(0);
      opacity:1;
    }
    .sheetHandle{
      width: 58px;
      height: 6px;
      border-radius: 999px;
      background: rgba(0,0,0,.12);
      margin: 2px auto 10px;
    }
    [data-theme="night"] .sheetHandle{background: rgba(255,255,255,.12)}

    .sheetTabs{
      display:flex;
      gap:10px;
      padding: 2px 4px 10px;
    }
    .sheetTab{
      flex:1;
      border:1px solid var(--line);
      background: rgba(0,0,0,.02);
      color: var(--text);
      border-radius: 16px;
      padding: 10px 10px;
      font-weight: 950;
      cursor:pointer;
    }
    [data-theme="night"] .sheetTab{background: rgba(255,255,255,.03)}
    .sheetTab.active{
      background: rgba(30,136,229,.14);
    }

    .setHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:6px 4px 10px;
      border-bottom:1px solid var(--line);
      margin-bottom:10px;
    }
    .setTitle{font-weight:950}
    .row{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 4px;
    }
    .row small{color:var(--muted)}
    .seg{
      display:flex;gap:8px;align-items:center;
      border:1px solid var(--line);
      border-radius:14px;padding:6px;
      background:rgba(0,0,0,.02);
    }
    [data-theme="night"] .seg{background:rgba(255,255,255,.03)}
    .seg button{
      border:none;background:transparent;cursor:pointer;
      padding:8px 10px;border-radius:12px;font-weight:950;color:var(--text)
    }
    .seg button.active{background:rgba(30,136,229,.14)}
    .toggle{
      width:46px;height:28px;border-radius:999px;
      background:rgba(0,0,0,.12);
      position:relative;border:1px solid var(--line);cursor:pointer;
    }
    [data-theme="night"] .toggle{background:rgba(255,255,255,.12)}
    .knob{
      width:24px;height:24px;border-radius:50%;
      background:var(--card);
      position:absolute;top:1px;left:1px;
      transition:left .15s ease;
      border:1px solid var(--line);
    }
    .toggle.on{background:rgba(30,136,229,.25)}
    .toggle.on .knob{left:21px}
    .range{width:170px}
    .hint{font-size:12px;color:var(--muted);padding:0 4px 8px}
    select{
      border:1px solid var(--line);
      background:var(--card);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      outline:none;
      min-width:170px;
      font-weight:900;
    }
  
/* ===========================
   Mobile App UI (Books / My Library / Details)
=========================== */
:root{
  --appBg:#F5F3EE;
  --appCard:#FAF9F7;
  --appCardSolid:#FAF9F7;
  --appText:#000000;
  --appSub:rgba(54,53,53,.5);
  --appShadow:0 2px 17.5px rgba(0,0,0,.07);
  --appRadius:24px;
  --appRadiusSm:20px;
}
body{ background: var(--appBg); }

.homeScreen{ position:relative; }
.homeScreen::after{
  content:"";
  position:fixed;
  left:0; right:0;
  top: 54vh;
  bottom:0;
  /* Keep the same app background color (no half-white screen) */
  background: var(--appBg);
  z-index:-1;
}
@media (min-width:768px){
  .homeScreen::after{ top: 52vh; }
}

.wrap{ max-width: 980px; }

.appHeader{
  display:flex; align-items:flex-end; justify-content:flex-start;
  gap:22px; padding: 56px 20px 8px 20px;
}
.appHeader .tab{
  font-size:56px; line-height:1; font-weight:900; letter-spacing:-.02em;
  background:none; border:none; padding:0; cursor:pointer;
}
.appHeader .tab.muted{color:rgba(54,53,53,.3)}
@media (max-width:460px){
  .appHeader .tab{ font-size:44px; }
}

.sectionLabel{
  padding: 8px 18px 10px 18px;
  color: rgba(54,53,53,.3);
  font-weight:800;
  letter-spacing:.08em;
  text-transform:uppercase;
  font-size:14px;
}

.cardWide{
  margin: 0 20px 20px 20px;
  background: var(--appCardSolid);
  border-radius: 12px;
  box-shadow: 0 2px 17.5px rgba(0,0,0,.07);
  border: 1px solid rgba(84,84,86,.15);
  padding: 8px;
  display:flex; gap:16px; align-items:center;
}
.cardWide .coverImg{
  width:70px; height:107px; border-radius:8px; overflow:hidden; flex:0 0 auto;
  box-shadow: 0 4px 32px rgba(0,0,0,.05);
  background:#ddd;
}
.cardWide .coverImg img{ width:100%; height:100%; object-fit:cover; display:block; }
.cardWide .info{ flex:1; min-width:0; }
.cardWide .title{ font-size:24px; font-weight:900; margin:0 0 4px 0; color:var(--appText); }
.cardWide .meta{ margin:0; color: rgba(0,0,0,.45); font-weight:700; }

.circle{
  width:62px; height:62px; border-radius:999px; display:grid; place-items:center;
  background: conic-gradient(var(--primary) var(--p,0%), rgba(0,0,0,.08) 0);
}
.circle .inner{
  width:52px; height:52px; border-radius:999px; background:#fff;
  display:grid; place-items:center;
  font-weight:900; color: rgba(0,0,0,.55);
}

.groupCard{
  margin: 10px 18px 22px 18px;
  background: rgba(255,255,255,.55);
  border-radius: var(--appRadius);
  box-shadow: var(--appShadow);
  padding: 16px 14px 18px 14px;
}
.groupTitleRow{ display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; }
.groupTitle{ font-size:40px; font-weight:950; letter-spacing:-.02em; margin:0; }
.chevBtn{
  border:none; background: rgba(0,0,0,.06);
  width:44px; height:44px; border-radius:999px;
  font-size:30px; line-height:1; cursor:pointer;
}
.hScroll{ display:flex; gap:16px; overflow:auto; padding: 4px 4px 2px 4px; }
.bookTile{ width:160px; flex:0 0 auto; cursor:pointer; }
.bookTile .tileCover{
  width:160px; height:220px; border-radius:22px; overflow:hidden;
  box-shadow:0 14px 28px rgba(0,0,0,.18);
  background:#ddd; position:relative;
}
.bookTile .tileCover img{ width:100%; height:100%; object-fit:cover; display:block; }
.bookTile .tileMeta{
  padding-top:10px;
}
.bookTile .tileTitle{ font-weight:900; font-size:18px; margin:0; }
.bookTile .tileSub{ margin:0; color: rgba(0,0,0,.45); font-weight:700; }

.segmented{
  display:inline-flex;
  gap:0;
  padding:4px;
  border-radius:999px;
  background:#FFFFFF;
  border:1px solid rgba(0,0,0,.10);
  box-shadow:0 2px 17.5px rgba(0,0,0,.07);
}
.libSegBtn{
  border:none;
  padding:10px 18px;
  border-radius:999px;
  cursor:pointer;
  font-weight:900;
  font-size:16px;
  background:transparent;
  color: rgba(0,0,0,.55);
  min-width: 110px;
}
.libSegBtn.active{ background:#000; color:#fff; }

@media (max-width:460px){
  .libSegBtn{ padding:10px 12px; font-size:14px; min-width: 98px; }
}

.libraryList{ padding: 10px 18px 22px 18px; }
.libraryItem{
  display:flex;
  align-items:center;
  gap:16px;
  padding: 14px 18px;
  margin: 0 18px 14px 18px;
  background: transparent;
}
.libraryItem:last-child{ border-bottom:none; }
.libraryItem .coverImg{ width:86px; height:110px; border-radius:18px; overflow:hidden; background:#ddd; }
.libraryItem .coverImg img{ width:100%; height:100%; object-fit:cover; display:block; }
.libraryItem .title{ font-size:28px; font-weight:950; margin:0 0 4px 0; }
.libraryItem .meta{ margin:0; color: rgba(0,0,0,.40); font-weight:800; }

/* Compact language-package progress pills under a book title */
.pkgRow{ display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
.pkgChip{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border-radius:999px;
  background: rgba(255,255,255,.55);
  border:1px solid rgba(0,0,0,.06);
  font-weight:900;
  font-size:13px;
  color: rgba(0,0,0,.85);
  max-width: 260px;
}
.pkgChip .pct{ opacity:.75; font-weight:950; }
.pkgChip .mode{ opacity:.7; font-weight:950; }
.pkgChip .arrow{ opacity:.7; }

@media (max-width:460px){
  .pkgChip{ font-size:12px; padding:6px 9px; max-width: 220px; }
}

/* Bookmarks list */
.bmBook{ margin: 0 18px 18px 18px; }
.bmHead{
  display:flex;
  align-items:center;
  gap:14px;
  padding: 10px 0 6px 0;
}
.bmCover{ width:56px; height:72px; border-radius:16px; overflow:hidden; background:#ddd; }
.bmCover img{ width:100%; height:100%; object-fit:cover; display:block; }
.bmTitle{ font-size:22px; font-weight:950; margin:0; line-height:1.15; }
.bmItems{ display:flex; flex-direction:column; gap:10px; padding: 6px 0 8px 0; }
.bmItem{
  display:flex;
  align-items:flex-start;
  gap:12px;
  padding: 12px 14px;
  border-radius: 18px;
  background: rgba(255,255,255,.55);
  border: 1px solid rgba(0,0,0,.06);
}
.bmMain{ flex:1; min-width:0; }
.bmLabel{ font-size:13px; font-weight:900; color: rgba(0,0,0,.45); margin:0 0 6px 0; }
.bmPair{ display:inline-block; margin-left:8px; font-size:12px; font-weight:800; color: rgba(0,0,0,.55); }
.bmRaw{ font-weight:900; color: rgba(0,0,0,.85); margin:0 0 4px 0; line-height:1.25; }
.bmTr{ font-weight:800; color: rgba(0,0,0,.55); margin:0; line-height:1.25; }
.bmBtns{ display:flex; flex-direction:column; gap:8px; align-items:flex-end; }
.bmBtn{ border:none; background: rgba(0,0,0,.06); width:44px; height:44px; border-radius:16px; cursor:pointer; font-weight:950; }
.bmBtn.primary{ background:#000; color:#fff; }

.detailsWrap{
  padding: 18px;
}
.detailsTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 18px 18px 0 18px;
}
.iconBtn{
  border:none;
  background: rgba(0,0,0,.06);
  width:44px;height:44px;border-radius:16px;
  display:inline-flex;align-items:center;justify-content:center;
  cursor:pointer;
  box-shadow:none;
  font-weight:950;
  color: rgba(0,0,0,.75);
}
.detailsCover{
  width: 66vw; max-width: 320px; margin: 10px auto 16px auto;
  border-radius: 26px; overflow:hidden; box-shadow:0 20px 44px rgba(0,0,0,.22);
  background:#ddd;
}
.detailsCover img{ width:100%; height:auto; display:block; }
.detailsTitle{ font-size:44px; font-weight:950; text-align:center; margin: 8px 0 6px 0; letter-spacing:-.02em;}
.detailsMeta{ text-align:center; color: rgba(0,0,0,.45); font-weight:800; margin:0 0 14px 0; font-size:18px;}
.detailsDesc{
  background: rgba(255,255,255,.55);
  white-space: pre-line;
  border-radius: 18px; padding: 14px;
  color: rgba(0,0,0,.55); font-weight:700; line-height:1.35;
  border:1px solid rgba(0,0,0,.06);
}
.formCard{
  margin-top:14px;
  background: rgba(255,255,255,.55);
  border-radius: var(--appRadius);
  border:1px solid rgba(0,0,0,.06);
  overflow:hidden;
}
.formRow{
  display:flex; align-items:center; justify-content:space-between;
  padding: 16px 16px;
  border-top: 1px solid rgba(0,0,0,.06);
}
.formRow:first-child{ border-top:none; }
.formRow .label{ font-size:20px; font-weight:950; }
.pillBtn{
  border:none; background:#fff; border-radius:999px;
  padding: 10px 14px; font-weight:900; cursor:pointer;
  display:flex; align-items:center; gap:10px;
  box-shadow:0 10px 20px rgba(0,0,0,.08);

  position:relative;
  overflow:hidden;
}

.pillBtn .selOverlay{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  opacity:0;
  cursor:pointer;
  -webkit-appearance:none;
  appearance:none;
  border:0;
  background:transparent;
}

.bigActions{
  display:flex; gap:14px; margin-top: 14px;
}
.bigBtn{
  flex:1; border:none; border-radius: 22px; padding: 18px 16px;
  font-size:22px; font-weight:950; cursor:pointer;
  background: linear-gradient(135deg, rgba(30,136,229,.85), rgba(42,167,255,.95));
  color:#fff;
  display:flex; align-items:center; justify-content:center; gap:10px;
}
.bigBtn.secondary{
  background: linear-gradient(135deg, rgba(30,136,229,.55), rgba(42,167,255,.75));
}
@media (min-width: 900px), (orientation: landscape) and (min-width: 720px){
  .detailsGrid{ display:grid; grid-template-columns: 360px 1fr; gap: 22px; align-items:start; }
  .detailsCover{ width:100%; max-width:none; margin: 0; }
  .detailsTitle, .detailsMeta{ text-align:left; }
}
  /* Chapter headings (applies across all languages) */
  .listenLine.chapterLine .para{font-weight:950;letter-spacing:.2px;}
  .paraLine.chapterLine .line{font-weight:900;letter-spacing:.2px;}

</style>
</head>

<body data-theme="light">
  <div id="app"></div>

  <!-- Translation popover -->
  <div id="popover" class="popover" role="dialog" aria-hidden="true">
    <div class="popRow">
      <div class="popWord" id="popWord">word</div>
      <div class="popMiniBtns">
        <button class="miniBtn" id="popBookmark" title="Bookmark">üîñ</button>
        <button class="miniBtn" id="popSpeak" title="Speak">üîä</button>
      </div>
    </div>
    <div class="popTrans" id="popTrans">translation</div>
    <div class="popActions">
      <button class="popPlay" id="popPlayFromHere" title="Play from here">Play from here</button>
    </div>
  </div>

  <!-- Sheet backdrop -->
  <div id="sheetBackdrop" class="sheetBackdrop" aria-hidden="true"></div>

  <!-- Settings (User) -->
  <div id="settings" class="sheet" aria-hidden="true">
    <div class="sheetHandle" aria-hidden="true"></div>
    <div class="setHead">
      <div class="setTitle">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</div>
      <button class="miniBtn" id="setClose">‚úï</button>
    </div>

    <div class="sheetTabs" role="tablist" aria-label="Settings tabs">
      <button class="sheetTab active" id="setTabRead" role="tab" aria-selected="true">–¢–µ–∫—Å—Ç</button>
      <button class="sheetTab" id="setTabListen" role="tab" aria-selected="false">–ê—É–¥–∏–æ</button>
    </div>

    <div id="setPaneRead" class="sheetPane" role="tabpanel">
      <div class="row">
        <div>
          <div><b>–ú–æ–≤–∞ –ø–µ—Ä–µ–∫–ª–∞–¥—É</b></div>
          <small>LibreTranslate target</small>
        </div>
        <select id="targetLang"></select>
      </div>

      <div class="row">
        <div>
          <div><b>–†–æ–∑–º—ñ—Ä —Ç–µ–∫—Å—Ç—É</b></div>
          <small>A‚àí / A+</small>
        </div>
        <div class="seg">
          <button id="fontMinus">A‚àí</button>
          <button id="fontPlus">A+</button>
        </div>
      </div>

      <div class="row">
        <div>
          <div><b>–ö–æ–ª—ñ—Ä –ø—ñ–¥—Å–≤—ñ—Ç–∫–∏</b></div>
          <small>Default / Yellow</small>
        </div>
        <div class="seg">
          <button id="hlDefault" class="active">Default</button>
          <button id="hlYellow">Yellow</button>
        </div>
      </div>

      <div class="row" id="rowTapTranslate">
        <div>
          <div><b>–ü–µ—Ä–µ–∫–ª–∞–¥</b></div>
          <small>–ø–æ –∫–ª—ñ–∫—É / —Ç–∞–ø—É</small>
        </div>
        <div class="toggle on" id="tTranslation"><div class="knob"></div></div>
      </div>

      <div class="row" id="rowLineTranslate" style="display:none">
        <div>
          <div><b>–ü–µ—Ä–µ–∫–ª–∞–¥ —Ä—è–¥–∫–æ–º</b></div>
          <small>–ø–æ–∫–∞–∑—É–≤–∞—Ç–∏ –ø—ñ–¥ —Ç–µ–∫—Å—Ç–æ–º</small>
        </div>
        <div class="toggle on" id="tLineTranslation"><div class="knob"></div></div>
      </div>

      <div class="row">
        <div>
          <div><b>–¢–µ–º–∞</b></div>
          <small>–Ω—ñ—á–Ω–∏–π —Ä–µ–∂–∏–º</small>
        </div>
        <div class="toggle" id="tNight"><div class="knob"></div></div>
      </div>

      <div class="row">
        <div>
          <div><b>–ü—ñ–¥—Å–≤—ñ—Ç–∫–∞</b></div>
          <small>–∞–∫—Ç–∏–≤–Ω–∏–π —Ä—è–¥–æ–∫</small>
        </div>
        <div class="toggle on" id="tHighlight"><div class="knob"></div></div>
      </div>

      <div class="row">
        <div>
          <div><b>–ü–æ–º—ñ–Ω—è—Ç–∏ –º–æ–≤–∏</b></div>
          <small>–ª–∏—à–µ —Ä–µ–∂–∏–º ‚Äú–ß–∏—Ç–∞—Ç–∏‚Äù</small>
        </div>
        <div class="toggle" id="tSwap"><div class="knob"></div></div>
      </div>
    </div>

    <div id="setPaneListen" class="sheetPane" role="tabpanel" style="display:none">
      <div class="row">
        <div>
          <div><b>–°—Ç–∞—Ç—å –≥–æ–ª–æ—Å—É</b></div>
          <small>—á–æ–ª–æ–≤—ñ—á–∏–π / –∂—ñ–Ω–æ—á–∏–π</small>
        </div>
        <div class="seg">
          <button id="uMale">–ß–æ–ª–æ–≤—ñ—á–∏–π</button>
          <button id="uFemale">–ñ—ñ–Ω–æ—á–∏–π</button>
        </div>
      </div>

      <div class="row">
        <div>
          <div><b>–®–≤–∏–¥–∫—ñ—Å—Ç—å —á–∏—Ç–∞–Ω–Ω—è</b></div>
          <small id="speedLabel">1.0√ó</small>
        </div>
        <div class="seg">
          <button id="uSpeedSlow">–ü–æ–≤—ñ–ª—å–Ω–æ</button>
          <button id="uSpeedNormal">–ù–æ—Ä–º–∞–ª—å–Ω–æ</button>
          <button id="uSpeedFast">–®–≤–∏–¥–∫–æ</button>
        </div>
      </div>

      <!-- keep slider for fine-tuning (hidden in UI) -->
      <input id="speed" class="range" type="range" min="0.3" max="2.0" step="0.05" value="1.0" style="display:none">

      <div class="hint" style="padding-top:6px">
        –ù–æ—Ä–º–∞–ª—å–Ω–∞ —à–≤–∏–¥–∫—ñ—Å—Ç—å ‚Äî —Ü–µ –ø–æ—Ç–æ—á–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è (100).
      </div>
    </div>
  </div>


  <!-- Dev settings (–ê–¥–º—ñ–Ω) -->
  <div id="devPanel" class="sheet" aria-hidden="true">
    <div class="sheetHandle" aria-hidden="true"></div>
    <div class="setHead">
      <div class="setTitle">Dev / –ê–¥–º—ñ–Ω</div>
      <button class="miniBtn" id="devClose">‚úï</button>
    </div>

    <div class="row">
      <div>
        <div><b>–ü—Ä–æ–≤–∞–π–¥–µ—Ä –ø–µ—Ä–µ–∫–ª–∞–¥—É</b></div>
        <small>–¥–ª—è –ø–µ—Ä–µ–∫–ª–∞–¥—É —Ä—è–¥–∫—ñ–≤</small>
      </div>
      <div class="seg">
        <button id="provLibre">Libre</button>
        <button id="provOpenAI">OpenAI</button>
      </div>
    </div>

    <div class="row">
      <div>
        <div><b>–°—Ç–∞—Ç—å –≥–æ–ª–æ—Å—É</b></div>
        <small>—á–æ–ª–æ–≤—ñ—á–∏–π / –∂—ñ–Ω–æ—á–∏–π</small>
      </div>
      <div class="seg">
        <button id="vMale">–ß–æ–ª–æ–≤—ñ—á–∏–π</button>
        <button id="vFemale">–ñ—ñ–Ω–æ—á–∏–π</button>
      </div>
    </div>

    <div class="row">
      <div>
        <div><b>–ì–æ–ª–æ—Å</b></div>
        <small>–≤–±—É–¥–æ–≤–∞–Ω—ñ OpenAI</small>
      </div>
      <select id="ttsVoiceSelect"></select>
    </div>

    <div class="row" style="align-items:flex-start">
      <div style="min-width:140px">
        <div><b>–ü—Ä–æ–º–ø—Ç –≥–æ–ª–æ—Å—É</b></div>
        <small>—ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó</small>
      </div>
      <textarea id="ttsInstructions" style="width:100%;min-height:86px;border:1px solid var(--line);border-radius:12px;padding:10px;background:var(--card);color:var(--text);font-weight:700;resize:vertical"></textarea>
    </div>

    <div class="row">
      <div>
        <div><b>–ë–µ–∑ –∫–µ—à—É</b></div>
        <small>—ñ–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ –∫–µ—à Worker</small>
      </div>
      <div class="toggle" id="tNoCache"><div class="knob"></div></div>
    </div>

    <div class="ctaRow" style="margin-top:6px">
      <button class="btn btnGhost" id="btnClearTts">üßπ –û—á–∏—Å—Ç–∏—Ç–∏ –∫–µ—à –æ–∑–≤—É—á–µ–Ω–Ω—è</button>
      <button class="btn btnGhost" id="btnClearTr">üßπ –û—á–∏—Å—Ç–∏—Ç–∏ –∫–µ—à –ø–µ—Ä–µ–∫–ª–∞–¥—É</button>
    </div>

    <div class="hint" style="padding-top:10px">
      –ü–µ—Ä–µ–∫–ª–∞–¥: <b>LibreTranslate</b> (–ø—É–±–ª—ñ—á–Ω–∏–π —Å–µ—Ä–≤—ñ—Å). –Ø–∫—â–æ –±–∞—á–∏—à <b>429</b> ‚Äî —Ü–µ –ª—ñ–º—ñ—Ç. –ö–æ–¥ —Å—Ç–∞–≤–∏—Ç—å –ø–∞—É–∑—É —ñ –ø—Ä–æ—Å–∏—Ç—å –∑–∞—á–µ–∫–∞—Ç–∏.
      <br/><br/>
      –î–ª—è –±–µ–∑–ø–µ–∫–∏ –∫–ª—é—á OpenAI –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è —É Worker (secret). GitHub Pages –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è —Å—Ç–∞—Ç–∏—á–Ω–∏–º.
    </div>
  </div>

  

  <div id="chaptersSheet" class="sheet" aria-hidden="true">
    <div class="sheetHandle" aria-hidden="true"></div>
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px 14px 6px;">
      <div style="font-weight:900;letter-spacing:.2px">Chapters</div>
      <button class="btn" id="chaptersClose" style="padding:8px 12px">Close</button>
    </div>
    <div id="chaptersList" style="padding:6px 12px 18px;display:flex;flex-direction:column;gap:8px;"></div>
  </div>
<!-- Bottom player -->
  <div id="player" class="playerBar" style="display:none">
    <div class="playerInner">
      <div>
        <div class="progTop">
          <div class="progTitle" id="pTitle">Reader</div>
          <div class="progMeta"><span id="pPct">0%</span></div>
        </div>
        <div class="bar"><div id="pFill"></div></div>
      </div>
      <div class="controls">
        <button class="iconBtn" id="btnChapters" title="Chapters">‚â°</button>
        <button class="iconBtn" id="btnBack" title="Back">‚Üê</button>
        <button class="iconBtn" id="btnStart" title="To start">‚ü≤</button>
        <button class="playBtn" id="btnPlay" title="Play/Pause">‚ñ∂</button>

        <div class="modeSwitch" id="modeSwitch">
          <button class="modeBtn" id="modeListen" title="Listen" aria-label="Listen">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M12 3a7 7 0 0 0-7 7v4a4 4 0 0 0 4 4h1V8H9a5 5 0 0 1 10 0h-1v10h1a4 4 0 0 0 4-4v-4a7 7 0 0 0-7-7z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="modeBtn" id="modeRead" title="Read" aria-label="Read">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M7 4h10a2 2 0 0 1 2 2v13H7a2 2 0 0 0-2 2V6a2 2 0 0 1 2-2z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
              <path d="M7 4v15" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </button>
        </div>

      </div>
    </div>
  </div>

<script>
/* ===========================
   LibreTranslate (public)
=========================== */
const LIBRETRANSLATE_URL = "https://libretranslate.com/translate";
/* –ï—Å–ª–∏ —É —Ç–µ–±—è –±—É–¥–µ—Ç –∫–ª—é—á ‚Äî –≤—Å—Ç–∞–≤–∏—à—å —Å—é–¥–∞. –ò–Ω–∞—á–µ –æ—Å—Ç–∞–≤—å "" */
const LIBRETRANSLATE_API_KEY = "8178d78d-65e4-418c-a5cf-5197a75e9313";

/* ===========================
   Cloudflare Worker endpoints
   (keep OpenAI key ONLY in Worker secrets)
=========================== */
// Example: "https://your-worker.your-subdomain.workers.dev/translate"
const WORKER_TRANSLATE_URL = "https://books-4git-hab.englishclubsales.workers.dev/translate";
// Example: "https://your-worker.your-subdomain.workers.dev/tts"
const WORKER_TTS_URL = "https://books-4git-hab.englishclubsales.workers.dev/tts";

/* 6 —è–∑—ã–∫–æ–≤ (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ RU+UK) */
const TARGET_LANGS = [
  { code:"en", label:"English (EN)" },
{ code:"uk", label:"–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞ (UK)" },
  { code:"ru", label:"–†—É—Å—Å–∫–∏–π (RU)" },
  { code:"pl", label:"Polski (PL)" },
  { code:"de", label:"Deutsch (DE)" },
  { code:"es", label:"Espa√±ol (ES)" },
  { code:"fr", label:"Fran√ßais (FR)" }
];
/* –ú–æ–≤–∏ –∫–Ω–∏–≥–∏ (–æ—Ä–∏–≥—ñ–Ω–∞–ª—É) */
const SOURCE_LANGS = [
  { code:"en", label:"English (EN)" },
  ...TARGET_LANGS
];

// Flags for language picker UI
const FLAG_BY_LANG = {
  en: "üá¨üáß",
  uk: "üá∫üá¶",
  ru: "üá∑üá∫",
  pl: "üáµüá±",
  de: "üá©üá™",
  es: "üá™üá∏",
  fr: "üá´üá∑"
};
function flagFor(code){
  return FLAG_BY_LANG[code] || "üè≥Ô∏è";
}

function formatPkgLabel(sourceLang, targetLang, mode){
  const s = String(sourceLang||"").toLowerCase();
  const t = String(targetLang||"").toLowerCase();
  const m = String(mode||"").toLowerCase();
  const modeLabel = m==="listen" ? "Listen" : "Read";
  return `${flagFor(s)} ${s.toUpperCase()}‚Üí${flagFor(t)} ${t.toUpperCase()} (${modeLabel})`;
}

/* –ú–∞–ø–∞ –∫–æ–¥—É -> locale –¥–ª—è browser TTS */
const LANG_LOCALE = {
  en: "en-US",
  uk: "uk-UA",
  ru: "ru-RU",
  pl: "pl-PL",
  de: "de-DE",
  es: "es-ES",
  fr: "fr-FR"
};
function langToLocale(code){
  return LANG_LOCALE[code] || "en-US";
}


/* OpenAI built-in TTS voices */
const OPENAI_TTS_VOICES = [
  {id:"alloy", gender:"male"},
  {id:"ash", gender:"male"},
  {id:"ballad", gender:"male"},
  {id:"coral", gender:"female"},
  {id:"echo", gender:"male"},
  {id:"fable", gender:"male"},
  {id:"onyx", gender:"male"},
  {id:"nova", gender:"female"},
  {id:"sage", gender:"male"},
  {id:"shimmer", gender:"female"},
  {id:"verse", gender:"male"}
];

/* ===========================
   Books loading:
   /books/index.json
   /books/<id>/book.json
   Fallback-book is embedded.
=========================== */
const BOOKS_INDEX_URL = "books/index.json";

/* --------- Fallback book (—Ç–≤–æ—è –∫–Ω–∏–≥–∞ –æ—Å—Ç–∞–µ—Ç—Å—è) --------- */
const FALLBACK_BOOKS = [
  {
    id: "invisible-sandwich",
    series: "NEW",
    title_ua: "The Invisible Sandwich",
    title_en: "The Invisible Sandwich",
    level: "A1 English Learners",
    narrator: "–î–∏–∫—Ç–æ—Ä",
    durationMin: 12,
    sourceLang: "en",
    cover: "https://picsum.photos/seed/invisible-sandwich/800/900",
    description:
`The Invisible Sandwich

–£—Ä–æ–≤–µ–Ω—å - A1 English Learners

Enjoy a fun and simple English story made especially for A1 level learners.
The Invisible Sandwich is a short audio book with clear text and easy vocabulary. It is perfect for beginners who want to read and listen at the same time.
In this story, Tim makes a very strange sandwich. When he comes back to eat it, the sandwich is gone! Tim looks everywhere and becomes a Sandwich Detective. Step by step, he follows clues and tries to solve the mystery.`,
    text: [
      "The Invisible Sandwich",
      "Chapter 1: The Best Sandwich",
      "Tim is hungry, so he goes to the kitchen.",
      "‚ÄúI want a big sandwich!‚Äù he says.",
      "He gets some bread and adds cheese, tomato, and lettuce.",
      "The end."
    ]
  }
];

/* ---------------------------
   State
--------------------------- */
const state = {
  route: { name:"catalog", bookId:null },
  navStack: [],
  catalog: [],
  bookCache: new Map(),
  book: null,
  dev: {
    enabled: true,       // set false to hide dev menu completely
    open: false,

    // Providers
    translationProvider: "openai", // "openai" | "libre" (READ mode line translation + swap)
    ttsProvider: "openai",

    // TTS defaults
    ttsGender: "male",             // "male" | "female"
    ttsVoice: "onyx",              // OpenAI built-in voice
    ttsInstructions: "Deep calm narrator. Slow pace. Warm tone. Clear articulation. Pause briefly between sentences and a longer pause between paragraphs. Avoid sounding robotic.",
    speakTranslated: false,

    // Worker cache controls
    noCache: false
  },

  reading: {
    isPlaying:false,
    // TTS speed multiplier (OpenAI)
    speed: 1.0,
    fontSize: 22,
    showTranslation: true,
    lineTranslation: true,
    // READ mode: when true, translation becomes "primary" line
    swapLang: false,
    // LISTEN mode: what to speak: "source" | "target"
    listenLang: "source",
    night: false,
    highlight: true,
    highlightTheme: "default",
    targetLang: "uk",
    sourceLang: "en",
    listenMode: "original", // original | translation
    
    sourceLang: "en",
progress: 0,
    activeTokenIndex: -1,
    tokenMap: [],
    wordCount: 0,
    timer: null,

    // translation protection
    translateCache: new Map(),
    inFlight: false,
    lastReqAt: 0,
    cooldownUntil: 0
  }
};

const app = document.getElementById("app");
const player = document.getElementById("player");
const pTitle = document.getElementById("pTitle");
const pPct = document.getElementById("pPct");
const pFill = document.getElementById("pFill");
const btnPlay = document.getElementById("btnPlay");
const btnBack = document.getElementById("btnBack");
const btnStart = document.getElementById("btnStart");
const btnChapters = document.getElementById("btnChapters");
const chaptersSheet = document.getElementById("chaptersSheet");
const chaptersList = document.getElementById("chaptersList");
const chaptersClose = document.getElementById("chaptersClose");
const modeListen = document.getElementById("modeListen");
const modeRead = document.getElementById("modeRead");

const settings = document.getElementById("settings");
const setClose = document.getElementById("setClose");
const fontMinus = document.getElementById("fontMinus");
const fontPlus = document.getElementById("fontPlus");
const speed = document.getElementById("speed");
const speedLabel = document.getElementById("speedLabel");
const tTranslation = document.getElementById("tTranslation");
const rowTapTranslate = document.getElementById("rowTapTranslate");
const rowLineTranslate = document.getElementById("rowLineTranslate");
const tLineTranslation = document.getElementById("tLineTranslation");
const tNight = document.getElementById("tNight");
const tHighlight = document.getElementById("tHighlight");
const hlDefault = document.getElementById("hlDefault");
const hlYellow = document.getElementById("hlYellow");
const targetLangSelect = document.getElementById("targetLang");

// Sheets
const sheetBackdrop = document.getElementById("sheetBackdrop");
const setTabRead = document.getElementById("setTabRead");
const setTabListen = document.getElementById("setTabListen");
const setPaneRead = document.getElementById("setPaneRead");
const setPaneListen = document.getElementById("setPaneListen");
const uMale = document.getElementById("uMale");
const uFemale = document.getElementById("uFemale");
const uSpeedSlow = document.getElementById("uSpeedSlow");
const uSpeedNormal = document.getElementById("uSpeedNormal");
const uSpeedFast = document.getElementById("uSpeedFast");


// Dev panel
const devPanel = document.getElementById("devPanel");
const devClose = document.getElementById("devClose");
const provLibre = document.getElementById("provLibre");
const provOpenAI = document.getElementById("provOpenAI");
const vMale = document.getElementById("vMale");
const vFemale = document.getElementById("vFemale");
const ttsVoiceSelect = document.getElementById("ttsVoiceSelect");
const tSwap = document.getElementById("tSwap");
const ttsInstructions = document.getElementById("ttsInstructions");
const tNoCache = document.getElementById("tNoCache");
const btnClearTts = document.getElementById("btnClearTts");
const btnClearTr = document.getElementById("btnClearTr");

const popover = document.getElementById("popover");
const popWord = document.getElementById("popWord");
const popTrans = document.getElementById("popTrans");
const popPlayFromHere = document.getElementById("popPlayFromHere");
const popSpeak = document.getElementById("popSpeak");
const popBookmark = document.getElementById("popBookmark");

let popCtx = null; // {bookId, paraIdx, raw, tr}

function addBookmarkFromPopover(){
  try{
    if(!popCtx) return;
    const bookId = popCtx.bookId || state.book?.id || state.route?.bookId;
    const raw = popCtx.raw || popWord?.textContent || "";
    const tr = popCtx.tr || popTrans?.textContent || "";
    const sLang = String(state.reading?.sourceLang || state.book?.sourceLang || "en").trim().toLowerCase();
    const tLang = String(state.reading?.targetLang || "uk").trim().toLowerCase();
    const m = pkgMode(state.route?.name);
    addBookmarkEntry({bookId, paraIdx: popCtx.paraIdx || 0, raw, tr, sourceLang: sLang, targetLang: tLang, mode: m});

    // quick UI feedback
    if(popBookmark){
      const prev = popBookmark.textContent;
      popBookmark.textContent = "‚úì";
      setTimeout(()=>{ try{ popBookmark.textContent = prev; }catch(e){} }, 650);
    }

    // If user is currently on Bookmarks tab, refresh
    try{
      if(state.route?.name === "library" && state.ui?.libraryTab === "bookmarks"){ renderLibrary(); }
    }catch(e){}
  }catch(e){}
}

if(popBookmark){
  popBookmark.addEventListener("click", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    addBookmarkFromPopover();
  });
}

function langToBcp47(code){
  const c = String(code||"").toLowerCase();
  if(c==="uk") return "uk-UA";
  if(c==="ru") return "ru-RU";
  if(c==="pl") return "pl-PL";
  if(c==="de") return "de-DE";
  if(c==="es") return "es-ES";
  if(c==="fr") return "fr-FR";
  return "en-US";
}

function setTheme(night){
  document.body.setAttribute("data-theme", night ? "night" : "light");
}

function applyHighlightTheme(){
  if(state.reading.highlightTheme === "default"){
    const word = state.reading.night ? "rgba(42,167,255,.22)" : "rgba(42,167,255,.26)";
    const line = state.reading.night ? "rgba(42,167,255,.10)" : "rgba(42,167,255,.12)";
    const soft = state.reading.night ? "rgba(42,167,255,.06)" : "rgba(42,167,255,.07)";
    document.documentElement.style.setProperty("--hlWord", word);
    document.documentElement.style.setProperty("--hlLine", line);
    document.documentElement.style.setProperty("--hlLineSoft", soft);
    hlDefault.classList.add("active");
    hlYellow.classList.remove("active");
  }else{
    // Yellow theme
    document.documentElement.style.setProperty("--hlWord", "rgba(255, 213, 0, .34)");
    document.documentElement.style.setProperty("--hlLine", "rgba(255, 213, 0, .22)");
    document.documentElement.style.setProperty("--hlLineSoft", "rgba(255, 213, 0, .14)");
    hlYellow.classList.add("active");
    hlDefault.classList.remove("active");
  }
}

/* ===========================
   NEW: robust asset resolving for folder-based books
=========================== */
function isAbsoluteUrl(u){
  return /^https?:\/\//i.test(u) || /^data:/i.test(u);
}

function resolveBookAsset(bookId, path, fallbackFile){
  const p = (path && String(path).trim()) ? String(path).trim() : fallbackFile;
  if(!p) return "";
  if(isAbsoluteUrl(p)) return p;
  if(p.startsWith("books/")) return p;
  return `books/${encodeURIComponent(bookId)}/${p}`;
}

function normalizeCatalogItem(x){
  const id = x.id;
  return {
    ...x,
    id,
    cover: resolveBookAsset(id, x.cover, "cover.jpg")
  };
}

function normalizeBookJson(book, id){
  const b = {...book};
  b.id = b.id || id;
  b.sourceLang = b.sourceLang || "en";
  b.text = b.text || [];

  // Extract chapters markers and keep a cleaned text for reading/playback
  try{
    const processed = processBookTextForChapters(b.text);
    b.text = processed.text;
    b.chapters = processed.chapters;
  }catch(e){
    b.chapters = b.chapters || [];
  }

  b.cover = resolveBookAsset(b.id, b.cover, "cover.jpg");
  if(b.audio) b.audio = resolveBookAsset(b.id, b.audio, "");
  return b;
}

// ===== Chapters =====
// Marker format: [[CHAPTER: Title]] (this line is hidden from the reader)
function processBookTextForChapters(lines){
  const src = (lines || []).map(v=>String(v ?? ""));
  const out = [];
  const chapters = [];
  const markerRe = /^\s*\[\[CHAPTER:\s*(.+?)\s*\]\]\s*$/i;

  for(const line of src){
    const m = markerRe.exec(line);
    if(m){
      const title = String(m[1]||"").trim() || "Chapter";
      chapters.push({ title, startIndex: out.length });
      continue; // hide marker
    }
    out.push(line);
  }

  // Hybrid fallback: if no explicit markers, infer chapter starts by "two empty lines" before a heading-like line.
  if(!chapters.length){
    const isBlank = (s)=>{
      const v = String(s ?? "").replace(/\u00A0/g, " "); // NBSP -> space
      return v.trim() === "";
    };

    // Multilingual heading keywords (extendable)
    const headingRe = new RegExp(
      "^(" +
        "chapter|chapitre|kapitel|cap[i√≠]tulo|capitulo|rozdzia[l≈Ç]|rozdzial|rozdi[l≈Ç]|rozdi[l≈Ç]|rozd[i√≠]l|—Ä–æ–∑–¥—ñ–ª|–≥–ª–∞–≤–∞|—á–∞—Å—Ç–∏–Ω–∞|part|section" +
      ")(?:\s+|\s*[:.-]\s*)(?:\d+|[ivxlcdm]+)(?:\s*[:.-].*)?$",
      "i"
    );

    const looksLikeHeading = (line)=>{
      const cur = String(line ?? "").replace(/\u00A0/g, " ").trim();
      if(!cur) return false;
      if(cur.length > 90) return false;
      // if it matches known keywords, accept
      if(headingRe.test(cur)) return true;

      // Generic: short line, has a number/roman numeral, few words
      const words = cur.split(/\s+/).filter(Boolean);
      if(words.length <= 10 && (/[0-9]/.test(cur) || /\b[IVXLCDM]{1,8}\b/i.test(cur))){
        // avoid normal sentences (end with period + long)
        if(!/[.!?]$/.test(cur) || cur.includes(":")) return true;
      }
      return false;
    };

    for(let i=0;i<out.length;i++){
      const curLine = out[i] ?? "";
      if(isBlank(curLine)) continue;
      const prev1 = out[i-1] ?? "";
      const prev2 = out[i-2] ?? "";
      if(isBlank(prev1) && isBlank(prev2)){
        const cur = String(curLine).replace(/\u00A0/g, " ").trim();
        if(looksLikeHeading(cur)){
          chapters.push({ title: cur, startIndex: i });
        }
      }
    }
  }

  // Always include a default chapter for convenience
  if(!chapters.length){
    chapters.push({ title: "Start", startIndex: 0 });
  }

  return { text: out, chapters };
}

function getChapters(){
  return (state.book && Array.isArray(state.book.chapters)) ? state.book.chapters : [];
}

function _escHtml(s){
  return String(s||"")
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#39;');
}

function renderChaptersList(){
  if(!chaptersList) return;
  const ch = getChapters();
  if(!ch.length){
    chaptersList.innerHTML = '<div style="opacity:.6;font-weight:700;padding:8px 2px">No chapters in this book.</div>';
    return;
  }
  chaptersList.innerHTML = ch.map((c, idx)=>{
    const title = _escHtml(String(c.title||"Chapter"));
    return `<button class="btn" style="text-align:left;justify-content:flex-start;gap:10px" data-chapter="${idx}">
      <span style="font-weight:900;opacity:.8">${idx+1}.</span>
      <span style="flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${title}</span>
      <span style="opacity:.6">‚Ä∫</span>
    </button>`;
  }).join('');

  [...chaptersList.querySelectorAll('[data-chapter]')].forEach(btn=>{
    btn.onclick = (e)=>{
      e.preventDefault();
      const idx = Number(btn.getAttribute('data-chapter'));
      jumpToChapter(idx);
      closeChapters();
    };
  });
}

function openChapters(){
  if(!chaptersSheet) return;
  try{ closeSettings(); }catch(e){}
  try{ closeDev(); }catch(e){}
  renderChaptersList();
  chaptersSheet.setAttribute('aria-hidden','false');
  openSheet(chaptersSheet);
}
function closeChapters(){
  if(!chaptersSheet) return;
  closeSheet(chaptersSheet);
}

function jumpToChapter(chIdx){
  const ch = getChapters();
  if(!ch.length) return;
  const c = ch[Math.max(0, Math.min(ch.length-1, Number(chIdx)||0))];
  const idx = Math.max(0, Number(c.startIndex||0));

  try{ stopReading(); }catch(e){}

  if(state.route?.name === 'reader'){
    openaiLineIndex = idx;
    state.reading.activeParaIndex = idx;
    state.reading.resumeIndexReader = idx;
    try{ clearActivePara(); }catch(e){}
    try{ setActivePara(idx); }catch(e){}
    setTimeout(()=>{ try{ scrollToPara(idx); }catch(e){} }, 50);
    updateProgressUI();
    saveReadingProgress();
  }else if(state.route?.name === 'bireader'){
    state.reading.activeBiLineIndex = idx;
    state.reading.resumeIndexBi = idx;
    openaiLineIndex = idx;
    try{ clearActiveLineUI(); }catch(e){}
    try{ setActiveLineUI(idx); }catch(e){}
    setTimeout(()=>{ try{ scrollToLine(idx); }catch(e){} }, 50);
    updateProgressUI();
    saveReadingProgress();
  }
}
/* ---------------------------
   Back
--------------------------- */
function appBack(){
  // In the app, Back should NOT bounce between Read/Listen modes.
  // From any reading screen we return to the Book Details screen (language + description).
  try{
    const r = state.route?.name;
    if(r === "reader" || r === "bireader"){
      const bookId = resolveBookId();
      if(bookId){
        go({name:"details", bookId}, {push:false});
      }else{
        go({name:"catalog"}, {push:false});
      }
      return;
    }
  }catch(e){}

  try{
    if(window.ReactNativeWebView && typeof window.ReactNativeWebView.postMessage === "function"){
      window.ReactNativeWebView.postMessage(JSON.stringify({type:"BACK"}));
      return;
    }
  }catch(e){}
  stopReading();
  const prev = state.navStack.pop();
  if(prev) go(prev, {push:false});
  else go({name:"catalog"}, {push:false});
}


// Always exit to the Books catalog (not browser/app history)
function goCatalog(){
  try{ stopReading(); }catch(e){}
  try{ closeSettings(); }catch(e){}
  try{ closeDev(); }catch(e){}
  // clear nav stack so "Back" doesn't bounce around inside the reader
  try{ state.navStack = []; }catch(e){}
  go({name:"catalog"}, {push:false});
}

/* ---------------------------
   Router
--------------------------- */

/* ---------------------------
   Progress memory (per book, per mode) - survives navigation, resets on full reload
--------------------------- */
function resolveBookId(){
  const id = state.book?.id || state.book?.bookId || state.route?.bookId || state.route?.id;
  if(!id) return null;
  return String(id);
}

function progressKey(bookId, mode){
  return `book_progress::${bookId}::${mode}`;
}

// NEW: progress per "language package" (bookLang -> translationLang)
// IMPORTANT: progress must be SHARED between Read and Listen modes for the same book+language pair.
function pkgMode(routeName){
  // In this app routing: reader = Listen, bireader = Read
  if(routeName === "reader") return "listen";
  if(routeName === "bireader") return "read";
  return String(routeName||"");
}
function pkgProgressKey(bookId, sourceLang, targetLang){
  const s = String(sourceLang||"en").trim().toLowerCase();
  const t = String(targetLang||"uk").trim().toLowerCase();
  return `book_pkg_progress::${bookId}::${s}::${t}`;
}
function lastPkgKey(bookId){
  return `book_last_pkg::${bookId}`;
}

function globalLastInteractionKey(){
  return "app_last_interaction";
}

function setGlobalLastInteraction(bookId, mode, sourceLang, targetLang){
  try{
    const payload={
      bookId: String(bookId||""),
      mode: String(mode||"").trim().toLowerCase(),
      sourceLang: String(sourceLang||"en").trim().toLowerCase(),
      targetLang: String(targetLang||"uk").trim().toLowerCase(),
      ts: Date.now()
    };
    localStorage.setItem(globalLastInteractionKey(), JSON.stringify(payload));
  }catch(e){}
}

function getGlobalLastInteraction(){
  try{
    const s=localStorage.getItem(globalLastInteractionKey());
    if(!s) return null;
    const o=JSON.parse(s);
    if(!o || typeof o!=="object") return null;
    return o;
  }catch(e){
    return null;
  }
}

function saveLastPkg(bookId, routeName, sourceLang, targetLang){
  try{
    const payload = {
      mode: pkgMode(routeName),
      sourceLang: String(sourceLang||"en").trim().toLowerCase(),
      targetLang: String(targetLang||"uk").trim().toLowerCase(),
      ts: Date.now()
    };
    localStorage.setItem(lastPkgKey(bookId), JSON.stringify(payload));
    // also update global last interaction used for the home screen and ordering
    setGlobalLastInteraction(bookId, payload.mode, payload.sourceLang, payload.targetLang);
  }catch(e){}
}

function getLastPkg(bookId){
  try{
    const s = localStorage.getItem(lastPkgKey(bookId));
    if(!s) return null;
    const o = JSON.parse(s);
    if(!o || typeof o !== 'object') return null;
    return o;
  }catch(e){
    return null;
  }
}

function getPkgProgress(bookId, sourceLang, targetLang){
  try{
    const s = String(sourceLang||"en").trim().toLowerCase();
    const t = String(targetLang||"uk").trim().toLowerCase();
    const key = pkgProgressKey(bookId, s, t);
    let raw = localStorage.getItem(key) || sessionStorage.getItem(key);
    if(raw){
      return JSON.parse(raw);
    }

    // Backward-compat (older builds stored per-mode keys). If found, pick the latest and migrate.
    const legacyKeys = [
      `book_pkg_progress::${bookId}::listen::${s}::${t}`,
      `book_pkg_progress::${bookId}::read::${s}::${t}`
    ];
    let best = null;
    for(const lk of legacyKeys){
      try{
        const v = localStorage.getItem(lk) || sessionStorage.getItem(lk);
        if(!v) continue;
        const o = JSON.parse(v);
        if(o && typeof o === 'object'){
          if(!best || Number(o.ts||0) > Number(best.ts||0)) best = o;
        }
      }catch(_e){}
    }
    if(best){
      // migrate into the new shared key
      const migrated = {
        sourceLang: s,
        targetLang: t,
        progress: Number(best.progress||0),
        activeIndex: Number.isFinite(best.activeIndex) ? Number(best.activeIndex) : 0,
        ts: Number(best.ts||Date.now())
      };
      try{ localStorage.setItem(key, JSON.stringify(migrated)); }catch(e){
        try{ sessionStorage.setItem(key, JSON.stringify(migrated)); }catch(_e){}
      }
      return migrated;
    }
    return null;
  }catch(e){
    return null;
  }
}

function listPkgProgress(bookId){
  // Collect all saved package progresses for this book.
  const out = [];
  const prefix = `book_pkg_progress::${bookId}::`;
  try{
    const scan = (storage)=>{
      if(!storage) return;
      for(let i=0;i<storage.length;i++){
        const k = storage.key(i);
        if(!k || !k.startsWith(prefix)) continue;
        try{
          const v = storage.getItem(k);
          if(!v) continue;
          const o = JSON.parse(v);
          if(o && typeof o === 'object') out.push(o);
        }catch(_e){}
      }
    };
    scan(localStorage);
    scan(sessionStorage);
  }catch(e){}
  // Unique by source+target, keep latest ts
  const map = new Map();
  for(const o of out){
    const s = String(o.sourceLang||"").toLowerCase();
    const t = String(o.targetLang||"").toLowerCase();
    const id = `${s}::${t}`;
    const prev = map.get(id);
    if(!prev || Number(o.ts||0) > Number(prev.ts||0)) map.set(id, o);
  }
  return Array.from(map.values()).sort((a,b)=>Number(b.ts||0)-Number(a.ts||0));
}
function saveReadingProgress(){
  try{
    const bookId = resolveBookId();
    const mode = state.route?.name;
    if(!bookId) return;
    if(mode !== "reader" && mode !== "bireader") return;

    const payload = { scrollY: window.scrollY || 0 };

    if(mode === "reader"){
      payload.resumeIndex = Number.isFinite(state.reading.resumeIndexReader) ? state.reading.resumeIndexReader : (Number.isFinite(state.reading.activeParaIndex)? state.reading.activeParaIndex : 0);
      payload.activeParaIndex = Number.isFinite(state.reading.activeParaIndex) ? state.reading.activeParaIndex : payload.resumeIndex;
    }else{
      payload.activeBiLineIndex = Number.isFinite(state.reading.activeBiLineIndex) ? state.reading.activeBiLineIndex : 0;
      payload.resumeIndexBi = Number.isFinite(state.reading.resumeIndexBi) ? state.reading.resumeIndexBi : payload.activeBiLineIndex;
      payload.activeBiLineIndex = Number.isFinite(state.reading.activeBiLineIndex) ? state.reading.activeBiLineIndex : 0;
      payload.swapLang = !!state.reading.swapLang;
    }

    // store progress percent for catalog/library cards
    try{
      if(mode === "reader"){
        const total = Number(state.book?.text?.length || state.reading.totalParas || 0);
        const idx = Number.isFinite(payload.activeParaIndex) ? payload.activeParaIndex : 0;
        payload.total = total;
        payload.progress = total>0 ? Math.max(0, Math.min(100, ((idx+1)/total)*100)) : 0;
      }else{
        const total = Number(state.reading.biTotal || state.book?.text?.length || 0);
        const idx = Number.isFinite(payload.activeBiLineIndex) ? payload.activeBiLineIndex : 0;
        payload.total = total;
        payload.progress = total>0 ? Math.max(0, Math.min(100, ((idx+1)/total)*100)) : 0;
      }
    }catch(e){}

    // legacy progress (per mode)
    sessionStorage.setItem(progressKey(bookId, mode), JSON.stringify(payload));

    // NEW: progress per language package (book language + translation language) shared across modes
    try{
      const src = String(state.reading.sourceLang || state.book?.sourceLang || "en").trim().toLowerCase();
      const trg = String(state.reading.targetLang || "uk").trim().toLowerCase();
      const pkgKey = pkgProgressKey(bookId, src, trg);
      // capture cursor index for this mode so we can restore per (source‚Üítarget)
      let activeIndex = 0;
      try{
        const oi = Number.isFinite(openaiLineIndex) ? Number(openaiLineIndex) : null;
        if(mode === "reader"){
          const a = Number(state.reading.activeParaIndex);
          const r = Number(state.reading.resumeIndexReader);
          activeIndex = Number.isFinite(a) ? a : (Number.isFinite(r) ? r : (oi ?? 0));
        }else if(mode === "bireader"){
          const a = Number(state.reading.activeBiLineIndex);
          const r = Number(state.reading.resumeIndexBi);
          activeIndex = Number.isFinite(a) ? a : (Number.isFinite(r) ? r : (oi ?? 0));
        }else{
          activeIndex = oi ?? 0;
        }
        if(!Number.isFinite(activeIndex) || activeIndex < 0) activeIndex = 0;
      }catch(e){ activeIndex = 0; }

      const pkgPayload = {
        sourceLang: src,
        targetLang: trg,
        progress: Number(payload.progress||0),
        activeIndex: activeIndex,
        ts: Date.now()
      };
      try{ localStorage.setItem(pkgKey, JSON.stringify(pkgPayload)); }catch(e){
        try{ sessionStorage.setItem(pkgKey, JSON.stringify(pkgPayload)); }catch(_e){}
      }
      saveLastPkg(bookId, mode, src, trg);
    }catch(e){}
  }catch(e){}
}


function restoreReadingProgress(){
  try{
    const bookId = resolveBookId();
    const route = state.route?.name;
    if(!bookId) return 0;
    if(route !== "reader" && route !== "bireader") return 0;

    const src = String(state.reading.sourceLang || state.book?.sourceLang || "en").trim().toLowerCase();
    const trg = String(state.reading.targetLang || "uk").trim().toLowerCase();

    // 1) Prefer package progress (sourceLang + targetLang) shared across modes
    const pkg = getPkgProgress(bookId, src, trg);
    if(pkg && typeof pkg.activeIndex === "number"){
      const idx = Math.max(0, Number(pkg.activeIndex||0));

      // Keep indices in sync across Read/Listen so switching modes doesn't "jump back"
      try{
        state.reading.activeParaIndex = idx;
        state.reading.resumeIndexReader = idx;
      }catch(e){}
      try{
        state.reading.activeBiLineIndex = idx;
        state.reading.resumeIndexBi = idx;
      }catch(e){}
      openaiLineIndex = idx;

      // progress for current view
      const total = Number(state.book?.text?.length||0);
      state.reading.progress = total>0 ? (idx+1)/total : 0;

      return idx;
    }

    // 2) If there are *no* package progresses yet (old users), fallback to legacy per-mode progress
    const hasAnyPkgs = (listPkgProgress(bookId)||[]).length>0;
    if(!hasAnyPkgs){
      const key = progressKey(bookId, route);
      const raw = sessionStorage.getItem(key);
      if(raw){
        const p = JSON.parse(raw);
        if(route === "reader"){
          const idx = Number(p.activeParaIndex ?? p.resumeIndexReader ?? p.resumeIndex ?? 0);
          state.reading.activeParaIndex = Number.isFinite(idx) ? idx : 0;
          state.reading.resumeIndexReader = state.reading.activeParaIndex;
          openaiLineIndex = state.reading.activeParaIndex;
          const total = Number(state.book?.text?.length||0);
          state.reading.progress = total>0 ? (state.reading.activeParaIndex+1)/total : 0;
          return state.reading.activeParaIndex;
        }else{
          const idx = Number(p.activeBiLineIndex ?? p.resumeIndexBi ?? p.resumeIndex ?? 0);
          state.reading.activeBiLineIndex = Number.isFinite(idx) ? idx : 0;
          state.reading.resumeIndexBi = state.reading.activeBiLineIndex;
          openaiLineIndex = state.reading.activeBiLineIndex;
          const total = Number(state.book?.text?.length||0);
          state.reading.progress = total>0 ? (state.reading.activeBiLineIndex+1)/total : 0;
          return state.reading.activeBiLineIndex;
        }
      }
    }

    // 3) Otherwise: no progress for this pair => start from beginning
    if(route === "reader"){
      state.reading.activeParaIndex = 0;
      state.reading.resumeIndexReader = 0;
    }else{
      state.reading.activeBiLineIndex = 0;
      state.reading.resumeIndexBi = 0;
    }
    state.reading.progress = 0;
    openaiLineIndex = 0;
    return 0;
  }catch(e){
    try{ openaiLineIndex = 0; }catch(_e){}
    return 0;
  }
}



function applyLanguagePairChange(){
  try{ saveReadingProgress(); }catch(e){}
  try{ stopReading(); }catch(e){}
  // reset cursor so new pairs never inherit the old line index
  try{ openaiLineIndex = 0; }catch(e){}
  try{ state.reading.activeParaIndex = 0; state.reading.resumeIndexReader = 0; }catch(e){}
  try{ state.reading.activeBiLineIndex = 0; state.reading.resumeIndexBi = 0; }catch(e){}
  const idx = (()=>{
    try{ return restoreReadingProgress() || 0; }catch(e){ return 0; }
  })();

  try{
    if(state.route?.name === "reader"){
      try{ clearActivePara(); }catch(e){}
      try{ setActivePara(idx); }catch(e){}
      setTimeout(()=>{ try{ scrollToPara(idx); }catch(e){} }, 60);
    }else if(state.route?.name === "bireader"){
      try{ clearActiveLine(); }catch(e){}
      try{ setActiveLine(idx); }catch(e){}
      setTimeout(()=>{ try{ scrollToLine(idx); }catch(e){} }, 60);
    }
  }catch(e){}
  try{ updateProgressUI(); }catch(e){}
}
/* ---------------------------
   Bookmarks (per book)
--------------------------- */
function bmKey(bookId){ return `bm:${bookId}`; }
function loadBookmarks(bookId){
  try{
    const s = localStorage.getItem(bmKey(bookId)) || sessionStorage.getItem(bmKey(bookId));
    if(!s) return [];
    const arr = JSON.parse(s);
    return Array.isArray(arr) ? arr : [];
  }catch(e){
    return [];
  }
}
function saveBookmarks(bookId, arr){
  try{ localStorage.setItem(bmKey(bookId), JSON.stringify(arr||[])); }catch(e){
    try{ sessionStorage.setItem(bmKey(bookId), JSON.stringify(arr||[])); }catch(_e){}
  }
}
function addBookmarkEntry({bookId, paraIdx, raw, tr}){
  if(!bookId) return;
  const r = String(raw||"").trim();
  const t = String(tr||"").trim();
  if(!r && !t) return;
  const list = loadBookmarks(bookId);
  const entry = {
    id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
    paraIdx: Number.isFinite(paraIdx) ? Number(paraIdx) : 0,
    raw: r,
    tr: t,
    createdAt: Date.now()
  };
  // Requirement: new bookmark from the same book goes UNDER existing ones (append)
  list.push(entry);
  saveBookmarks(bookId, list);
}
function removeBookmarkEntry(bookId, entryId){
  if(!bookId || !entryId) return;
  const list = loadBookmarks(bookId).filter(x=>x && x.id !== entryId);
  saveBookmarks(bookId, list);
}
function hasAnyBookmarks(bookId){
  try{ return loadBookmarks(bookId).length>0; }catch(e){ return false; }
}

function go(route, {push=true}={}){
  if(push && state.route && state.route.name){
    state.navStack.push({...state.route});
  }
  // save progress before leaving reading screens
  if(state.route && (state.route.name === 'reader' || state.route.name === 'bireader')){
    saveReadingProgress();
  }
  state.route = route;
  document.body.dataset.route = route.name || "";
  updateModeSwitchUI();

  if(route.name === "catalog"){
    state.book = null;
    stopReading();
    renderCatalog();
    hidePlayer();
  }
  
  if(route.name === "library"){
    state.book = null;
    stopReading();
    renderLibrary();
    hidePlayer();
  }
if(route.name === "details"){
    stopReading();
    openaiLineIndex = 0;
    state.reading.activeParaIndex = 0;
    state.reading.resumeIndexReader = 0;
    state.reading.activeBiLineIndex = 0;
    state.reading.resumeIndexBi = 0;
    loadBook(route.bookId, state.reading.sourceLang).then(book=>{
      state.book = book;
      renderDetails();
      hidePlayer();
    });
  }
  if(route.name === "reader"){
    stopReading();
    // ensure defaults exist
    state.reading.targetLang = state.reading.targetLang || "uk";

    openaiLineIndex = 0;
    state.reading.activeParaIndex = 0;
    state.reading.resumeIndexReader = 0;
    state.reading.activeBiLineIndex = 0;
    state.reading.resumeIndexBi = 0;

    loadBook(route.bookId, state.reading.sourceLang).then(book=>{
      state.book = book;
      renderReader();
      showPlayer();

      const idx = restoreReadingProgress() || 0;
      try{ clearActivePara(); }catch(e){}
      try{ setActivePara(idx); }catch(e){}
      setTimeout(()=>{ try{ scrollToPara(idx); }catch(e){} }, 60);
      try{ updateProgressUI(); }catch(e){}
    });
  }

  if(route.name === "bireader"){
    stopReading();
    // ensure defaults exist
    state.reading.targetLang = state.reading.targetLang || "uk";

    openaiLineIndex = 0;
    state.reading.activeParaIndex = 0;
    state.reading.resumeIndexReader = 0;
    state.reading.activeBiLineIndex = 0;
    state.reading.resumeIndexBi = 0;

    loadBook(route.bookId, state.reading.sourceLang).then(book=>{
      state.book = book;
      renderBiReader();
      showPlayer();

      const idx = restoreReadingProgress() || 0;
      try{ clearActiveLine(); }catch(e){}
      try{ setActiveLine(idx); }catch(e){}
      setTimeout(()=>{ try{ scrollToLine(idx); }catch(e){} }, 60);
      try{ updateProgressUI(); }catch(e){}
    });
  }
}

function hidePlayer(){ player.style.display="none"; }
function showPlayer(){
  player.style.display="block";
  pTitle.textContent = state.book?.title_en || "Reader";
  updateProgressUI();
}



function updateModeSwitchUI(){
  try{
    if(!modeListen || !modeRead) return;
    modeListen.classList.toggle("active", state.route?.name === "reader");
    modeRead.classList.toggle("active", state.route?.name === "bireader");
  }catch(e){}
}


/* ===========================
   Books loader (index.json + per-folder book.json) + fallback
=========================== */
async function loadCatalog(){
  const fallbackCatalog = FALLBACK_BOOKS.map(b => normalizeCatalogItem({
    id: b.id,
    series: b.series,
    title_ua: b.title_ua,
    title_en: b.title_en,
    level: b.level,
    durationMin: b.durationMin,
    cover: b.cover
  }));

  try{
    const res = await fetch(BOOKS_INDEX_URL, {cache:"no-store"});
    if(!res.ok) throw new Error("index not ok");
    const remoteRaw = await res.json();

    const remote = (remoteRaw || []).map(normalizeCatalogItem);

    const ids = new Set(remote.map(x=>x.id));
    state.catalog = [...remote, ...fallbackCatalog.filter(x=>!ids.has(x.id))];
  }catch(e){
    state.catalog = fallbackCatalog;
  }
}

async function loadBook(id, sourceLang){
  const lang = String(sourceLang || "en").trim().toLowerCase();
  const cacheId = `${id}::${lang}`;
  if(state.bookCache.has(cacheId)) return state.bookCache.get(cacheId);

  const basePath = `books/${encodeURIComponent(id)}`;
  const remoteUrl = `${basePath}/book.json`;

  try{
    const res = await fetch(remoteUrl, {cache:"no-store"});
    if(!res.ok) throw new Error("book not ok");
    const raw = await res.json();

    // If no "text" array provided, load plain text file.
    // Prefer book.<lang>.txt if it exists, otherwise fall back to book.txt (or raw.textFile).
    if(!raw.text){
      const fallbackFile = raw.textFile || "book.txt";
      const langFile = (lang && lang !== "en") ? `book.${lang}.txt` : null;

      async function fetchTextFile(fileName){
        const r = await fetch(`${basePath}/${fileName}`, {cache:"no-store"});
        if(!r.ok) return null;
        let txt = await r.text();
        txt = txt.replace(/^\uFEFF/, "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        return txt;
      }

      let txt = null;
      if(langFile){
        txt = await fetchTextFile(langFile);
      }
      if(txt == null){
        txt = await fetchTextFile(fallbackFile);
      }
      raw.text = txt ? txt.split("\n") : [];
    }

    const book = normalizeBookJson(raw, id);
    book.sourceLang = lang;

    state.bookCache.set(cacheId, book);
    return book;
  }catch(e){
    const fb = FALLBACK_BOOKS.find(b=>b.id===id) || FALLBACK_BOOKS[0];
    // keep fallback cached per lang key to prevent toggles from sticking to an older cached book
    state.bookCache.set(cacheId, fb);
    return fb;
  }
}

/* ---------------------------
   UI renderers
--------------------------- */
function renderTopbar(title){
  return `
    <div class="topbar">
      <div class="brand">
        <button class="navbtn" id="topBack" title="Back">‚Üê –ù–∞–∑–∞–¥</button>
        <div style="width:34px;height:34px;border-radius:12px;background:linear-gradient(135deg,#1e88e5,#2aa7ff);"></div>
        <div class="brandTitle">${escapeHtml(title)}</div>
        <span class="pill">GitHub Pages</span>
      </div>
      <button class="navbtn" id="topHome">–ö–∞—Ç–∞–ª–æ–≥</button>
    </div>
  `;
}

function renderCatalog(){
  // "Books" home screen
  const groups = {};
  state.catalog.forEach(b=>{
    const g = (b.series || "Books").trim();
    (groups[g] ||= []).push(b);
  });
  const groupNames = Object.keys(groups);

  // pick continue reading book = last interaction across books (fallback to max progress)
  let cont = null;
  let contPct = 0;
  try{
    const g = getGlobalLastInteraction();
    if(g && g.bookId){
      cont = state.catalog.find(b=>b.id===g.bookId) || null;
      if(cont){
        const lp = getPkgProgress(cont.id, g.sourceLang, g.targetLang);
        if(lp && typeof lp.progress === 'number') contPct = Number(lp.progress||0);
      }
    }
    if(!cont){
      for(const b of state.catalog){
        const pkgs = listPkgProgress(b.id);
        if(pkgs && pkgs.length){
          const latest = pkgs[0];
          const ts = Number(latest.ts||0);
          const bestTs = cont ? Number((listPkgProgress(cont.id)[0]||{}).ts||0) : -1;
          if(!cont || ts > bestTs){
            cont = b;
            contPct = Number(latest.progress||0);
          }
        }else{
          const r = JSON.parse(sessionStorage.getItem(progressKey(b.id,'reader') ) || "null");
          const br = JSON.parse(sessionStorage.getItem(progressKey(b.id,'bireader')) || "null");
          const p = Math.max(r?.progress||0, br?.progress||0);
          if(p > contPct){
            contPct = p;
            cont = b;
          }
        }
      }
    }
  }catch(e){}

  // Show progress for the last used language package (if available)
  let contShowPct = contPct;
  let contShowLabel = "";
  try{
    if(cont){
      const last = getLastPkg(cont.id);
      if(last){
        const lp = getPkgProgress(cont.id, last.sourceLang, last.targetLang);
        if(lp && typeof lp.progress === "number"){
          contShowPct = Number(lp.progress||0);
          contShowLabel = formatPkgLabel(last.sourceLang, last.targetLang, last.mode);
        }
      }
    }
  }catch(e){}

  app.innerHTML = `
    <div class="wrap homeScreen">
      <div class="appHeader">
        <button class="tab" id="tabBooks">Books</button>
        <button class="tab muted" id="tabLibrary">My Library</button>
      </div>

      ${cont ? `
        <div class="sectionLabel">Continue Reading</div>
        <div class="cardWide" id="continueCard" role="button" tabindex="0">
          <div class="coverImg">${cont.cover ? `<img src="${escapeHtml(cont.cover)}" alt="">` : ``}</div>
          <div class="info">
            <p class="title">${escapeHtml(cont.title_en || cont.title_ua || "Book")}</p>
            <p class="meta">${escapeHtml((cont.author||cont.series||""))}${cont.level ? ` ‚Ä¢ ${escapeHtml(cont.level)}` : ``}${contShowLabel?` ‚Ä¢ ${escapeHtml(contShowLabel)}`:``}</p>
          </div>
          <div class="circle" style="--p:${Math.round(contShowPct)}%">
            <div class="inner">${Math.round(contShowPct)}%</div>
          </div>
        </div>
      ` : ``}

      ${groupNames.map(g=>{
        const items = groups[g].slice(0, 10);
        return `
          <div class="groupCard">
            <div class="groupTitleRow">
              <h3 class="groupTitle">${escapeHtml(g)}</h3>
              <button class="chevBtn" data-group="${escapeHtml(g)}">‚Ä∫</button>
            </div>
            <div class="hScroll">
              ${items.map(b=>`
                <div class="bookTile" data-open="${escapeHtml(b.id)}">
                  <div class="tileCover">
                    ${b.cover ? `<img src="${escapeHtml(b.cover)}" alt="">` : ``}
                  </div>
                  <div class="tileMeta">
                    <p class="tileTitle">${escapeHtml(b.title_en || b.title_ua || "Book")}</p>
                    <p class="tileSub">${escapeHtml((b.author||"") || (b.series||""))}${b.level ? ` ‚Ä¢ ${escapeHtml(b.level)}`:``}</p>
                  </div>
                </div>
              `).join("")}
            </div>
          </div>
        `;
      }).join("")}
    </div>
  `;

  document.getElementById("tabBooks").onclick = ()=>go({name:"catalog"}, {push:false});
  document.getElementById("tabLibrary").onclick = ()=>go({name:"library"}, {push:false});

  if(cont){
    const openCont = ()=>go({name:"details", bookId: cont.id});
    const cc = document.getElementById("continueCard");
    cc.onclick = openCont;
    cc.onkeydown = (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); openCont(); } };
  }

  app.querySelectorAll("[data-open]").forEach(el=>{
    el.addEventListener("click", ()=>go({name:"details", bookId: el.dataset.open}));
  });

  app.querySelectorAll("[data-group]").forEach(el=>{
    el.addEventListener("click", ()=>alert("–§—ñ–ª—å—Ç—Ä–∏/–ø–æ—à—É–∫ –ø–æ –∂–∞–Ω—Ä—É –º–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ –ø—ñ–∑–Ω—ñ—à–µ."));
  });
}

function renderLibrary(){
  // My Library screen
  const tab = state.ui?.libraryTab || "progress"; // 'progress' | 'finished' | 'bookmarks'

  const hasBookmarks = (bookId)=>{
    try{
      const k = `bm:${bookId}`;
      const s = localStorage.getItem(k) || sessionStorage.getItem(k);
      if(!s) return false;
      const arr = JSON.parse(s);
      return Array.isArray(arr) && arr.length>0;
    }catch(e){
      return false;
    }
  };
  const rows = state.catalog.map(b=>{
    // main progress shown in UI = last used language package for this book (fallback to legacy max)
    let mainP = 0;
    let maxP = 0;
    let pkgs = [];
    try{
      pkgs = listPkgProgress(b.id);
      if(pkgs && pkgs.length){
        maxP = Math.max(...pkgs.map(x=>Number(x.progress||0)));
        const last = getLastPkg(b.id);
        if(last){
          const lp = getPkgProgress(b.id, last.sourceLang, last.targetLang);
          if(lp && typeof lp.progress === "number") mainP = Number(lp.progress||0);
          else mainP = Number(maxP||0);
        }else{
          mainP = Number(maxP||0);
        }
      }
    }catch(e){}
    // fallback to legacy progress if no package progress exists yet
    if(!pkgs || !pkgs.length){
      let r=null, br=null;
      try{
        r = JSON.parse(sessionStorage.getItem(progressKey(b.id,'reader')) || "null");
        br = JSON.parse(sessionStorage.getItem(progressKey(b.id,'bireader')) || "null");
      }catch(e){}
      maxP = Math.max(Number(r?.progress||0), Number(br?.progress||0));
      mainP = maxP;
    }
    const lastTs = (pkgs && pkgs.length) ? Number(pkgs[0].ts||0) : 0;
    return {b, p: mainP, maxP, lastTs, pkgs: (pkgs||[]).slice(0,3)};
  }).filter(x=> x.p>0 || tab==="finished"); // show all if finished? keep simple

  const inProgress = rows.filter(x=> x.maxP>0 && x.maxP<99.5).sort((a,b)=> (Number(b.lastTs||0)-Number(a.lastTs||0)) || (b.maxP-a.maxP));
  const finished = rows.filter(x=> x.maxP>=99.5).sort((a,b)=> (Number(b.lastTs||0)-Number(a.lastTs||0)) || (b.maxP-a.maxP));

  let list = (tab==="finished" ? finished : inProgress);
  if(tab==="bookmarks"){
    list = rows.filter(({b})=>hasBookmarks(b.id)).sort((a,b)=> (Number(b.lastTs||0)-Number(a.lastTs||0)) || (b.p-a.p));
  }

  let bookmarksGroups = [];
  if(tab==="bookmarks"){
    bookmarksGroups = list.map(({b})=>({
      b,
      items: loadBookmarks(b.id)
    })).filter(g=>g.items && g.items.length);
  }

  app.innerHTML = `
    <div class="wrap">
      <div class="appHeader">
        <button class="tab muted" id="tabBooks">Books</button>
        <button class="tab" id="tabLibrary">My Library</button>
      </div>

      <div style="padding: 0 18px 8px 18px;">
        <div class="segmented">
          <button class="libSegBtn ${tab==="progress"?"active":""}" id="libInProgress">In progress</button>
          <button class="libSegBtn ${tab==="finished"?"active":""}" id="libFinished">Finished</button>
          <button class="libSegBtn ${tab==="bookmarks"?"active":""}" id="libBookmarks">Bookmarks</button>
        </div>
      </div>

      <div class="libraryList">
        ${tab==="bookmarks" ? (
          (bookmarksGroups.length ? bookmarksGroups.map(({b,items})=>`
            <div class="bmBook">
              <div class="bmHead" data-open="${escapeHtml(b.id)}">
                <div class="bmCover">${b.cover ? `<img src="${escapeHtml(b.cover)}" alt="">` : ``}</div>
                <div style="flex:1; min-width:0;">
                  <p class="bmTitle">${escapeHtml(b.title_en || b.title_ua || "Book")}</p>
                </div>
              </div>
              <div class="bmItems">
                ${items.map((it, idx)=>`
                  <div class="bmItem" data-bm-item>
                    <div class="bmMain">
                      <p class="bmLabel">–ó–∞–∫–ª–∞–¥–∫–∞ ${idx+1} <span class="bmPair">${escapeHtml(formatPkgLabel((it.sourceLang||getLastPkg(b.id)?.sourceLang||state.reading?.sourceLang||"en"), (it.targetLang||getLastPkg(b.id)?.targetLang||state.reading?.targetLang||"uk"), (it.mode||getLastPkg(b.id)?.mode||"read")) )}</span></p>
                      <p class="bmRaw">${escapeHtml(it.raw || "")}</p>
                      <p class="bmTr">${escapeHtml(it.tr || "")}</p>
                    </div>
                    <div class="bmBtns">
                      <button class="bmBtn" data-bm-play="${escapeHtml(b.id)}::${escapeHtml(it.id)}" title="Play">üîä</button>
                      <button class="bmBtn primary" data-bm-go="${escapeHtml(b.id)}::${escapeHtml(it.id)}" title="Go">‚Ü™Ô∏é</button>
                      <button class="bmBtn" data-bm-del="${escapeHtml(b.id)}::${escapeHtml(it.id)}" title="Unbookmark">‚úï</button>
                    </div>
                  </div>
                `).join("")}
              </div>
            </div>
          `).join("") : `<div style="color:rgba(0,0,0,.45);font-weight:800;padding:18px 4px;">No bookmarks yet.</div>`)
        ) : (
          (list.length ? list.map(({b,p,pkgs})=>`
            <div class="libraryItem" data-open="${escapeHtml(b.id)}">
              <div class="coverImg">${b.cover ? `<img src="${escapeHtml(b.cover)}" alt="">` : ``}</div>
              <div style="flex:1; min-width:0;">
                <p class="title">${escapeHtml(b.title_en || b.title_ua || "Book")}</p>
                <p class="meta">${escapeHtml((b.author||b.series||""))}${b.level?` ‚Ä¢ ${escapeHtml(b.level)}`:``}</p>
                ${pkgs && pkgs.length ? `
                  <div class="pkgRow">
                    ${pkgs.map(x=>{
                      const s = String(x.sourceLang||"").toLowerCase();
                      const t = String(x.targetLang||"").toLowerCase();
                      const m = String(x.mode||"").toLowerCase();
                      const modeLabel = m==="listen" ? "Listen" : "Read";
                      const pct = Math.round(Number(x.progress||0));
                      return `<span class="pkgChip">${flagFor(s)} ${s.toUpperCase()} <span class="arrow">‚Üí</span> ${flagFor(t)} ${t.toUpperCase()} <span class="mode">${modeLabel}</span> <span class="pct">${pct}%</span></span>`;
                    }).join("")}
                  </div>
                ` : ``}
              </div>
              <div class="circle" style="--p:${Math.round(p)}%"><div class="inner">${Math.round(p)}%</div></div>
            </div>
          `).join("") : `<div style="color:rgba(0,0,0,.45);font-weight:800;padding:18px 4px;">No books yet.</div>`)
        )}
      </div>
    </div>
  `;

  document.getElementById("tabBooks").onclick = ()=>go({name:"catalog"}, {push:false});
  document.getElementById("tabLibrary").onclick = ()=>go({name:"library"}, {push:false});

  document.getElementById("libInProgress").onclick = ()=>{
    state.ui = state.ui || {};
    state.ui.libraryTab="progress";
    renderLibrary();
  };
  document.getElementById("libFinished").onclick = ()=>{
    state.ui = state.ui || {};
    state.ui.libraryTab="finished";
    renderLibrary();
  };

  document.getElementById("libBookmarks").onclick = ()=>{
    state.ui = state.ui || {};
    state.ui.libraryTab="bookmarks";
    renderLibrary();
  };

  app.querySelectorAll("[data-open]").forEach(el=>{
    el.addEventListener("click", ()=>go({name:"details", bookId: el.dataset.open}));
  });

  // bookmark buttons (play / go / delete)
  if(tab==="bookmarks"){
    app.querySelectorAll("[data-bm-play]").forEach(btn=>{
      btn.addEventListener("click", (e)=>{
        e.preventDefault();
        e.stopPropagation();
        const [bookId, entryId] = String(btn.dataset.bmPlay||"").split("::");
        const list = loadBookmarks(bookId);
        const it = list.find(x=>x && x.id===entryId);
        if(it) playOneShotTTS(it.raw || it.tr || "");
      });
    });
    app.querySelectorAll("[data-bm-go]").forEach(btn=>{
      btn.addEventListener("click", (e)=>{
        e.preventDefault();
        e.stopPropagation();
        const [bookId, entryId] = String(btn.dataset.bmGo||"").split("::");
        const list = loadBookmarks(bookId);
        const it = list.find(x=>x && x.id===entryId);
        const idx = Number(it?.paraIdx||0);
        go({name:"reader", bookId, startPara: idx});
      });
    });
    app.querySelectorAll("[data-bm-del]").forEach(btn=>{
      btn.addEventListener("click", (e)=>{
        e.preventDefault();
        e.stopPropagation();
        const [bookId, entryId] = String(btn.dataset.bmDel||"").split("::");
        removeBookmarkEntry(bookId, entryId);
        renderLibrary();
      });
    });
  }
}


function renderDetails(){
  if(!state.book){ return go({name:"catalog"}, {push:false}); }
  const b = state.book;

  // progress (show last used language package; fallback to max)
  let savedPct = 0;
  let savedLabel = "";
  try{
    const last = getLastPkg(b.id);
    if(last){
      const lp = getPkgProgress(b.id, last.sourceLang, last.targetLang);
      if(lp && typeof lp.progress === "number"){
        savedPct = Number(lp.progress||0);
        savedLabel = formatPkgLabel(last.sourceLang, last.targetLang, last.mode);
      }
    }
    if(!savedLabel){
      const pkgs = listPkgProgress(b.id);
      if(pkgs && pkgs.length){
        const best = pkgs.reduce((a,c)=> (Number(c.progress||0) > Number(a.progress||0) ? c : a), pkgs[0]);
        savedPct = Number(best.progress||0);
        // Package progress is shared across modes; show label using the last used mode if possible.
        const m = (getLastPkg(b.id)?.mode) || pkgMode(state.route?.name||"reader");
        savedLabel = formatPkgLabel(best.sourceLang, best.targetLang, m);
      }else{
        const r = JSON.parse(sessionStorage.getItem(progressKey(b.id,'reader')) || 'null');
        const br = JSON.parse(sessionStorage.getItem(progressKey(b.id,'bireader')) || 'null');
        savedPct = Math.max(Number(r?.progress||0), Number(br?.progress||0));
      }
    }
  }catch(e){}
  const pagesEst = b.pages ? Number(b.pages) : Math.max(1, Math.round(Number(b.text?.length||0)/8));

  const desc = (b.description_en || b.description || "").trim();
  const descHtml = desc ? escapeHtml(desc).replace(/\n/g, "<br>") : "";


  // default book language from metadata (fallback to state or 'en')
  const bookLang = b.sourceLang || state.reading.sourceLang || "en";
  state.reading.sourceLang = bookLang;

  // default translation language (persisted across the app)
  state.reading.targetLang = state.reading.targetLang || "uk";

  app.innerHTML = `
<div class="wrap">
  <div class="detailsWrap">
    <div class="detailsTop">
      <button class="iconBtn" id="detailsBack" title="Back">‚Äπ</button>
      <button class="iconBtn" id="detailsBookmark" title="Bookmark">üîñ</button>
    </div>

    <div class="detailsGrid">
      <div>
        <div class="detailsCover">
          ${b.cover ? `<img src="${escapeHtml(b.cover)}" alt="">` : ``}
        </div>
      </div>

      <div>
        <div>
          <h1 class="detailsTitle">${escapeHtml(b.title_en || b.title_ua || "Book")}</h1>
          <p class="detailsMeta">${escapeHtml((b.author||""))}${b.level?` ‚Ä¢ ${escapeHtml(String(b.level))}`:``}${pagesEst?` ‚Ä¢ ~${escapeHtml(String(pagesEst))} pages`:``}${savedPct||savedPct===0?` ‚Ä¢ ${escapeHtml(String(Math.round(savedPct)))}%`:``}${savedLabel?` ‚Ä¢ ${escapeHtml(savedLabel)}`:``}</p>
          <div class="detailsDesc">${descHtml}</div>
        </div>

        <div class="formCard">
          <div class="formRow">
            <div class="label">Book Language</div>
            <button class="pillBtn" id="detailsBookLangBtn"><span id="detailsBookFlag">üá¨üáß</span><span id="detailsBookLangLabel">English</span> <span style="opacity:.6;">‚ñæ</span><select id="dSourceLang" class="selOverlay"></select></button>
          </div>
          <div class="formRow">
            <div class="label">Translation Language</div>
            <button class="pillBtn" id="detailsTransLangBtn"><span id="detailsTransFlag">UA</span><span id="detailsTransLangLabel">Ukrainian</span> <span style="opacity:.6;">‚ñæ</span><select id="dTargetLang" class="selOverlay"></select></button>
          </div>
          
        </div>

        <div class="bigActions">
          <button class="bigBtn" id="btnRead">‚â° Read</button>
          <button class="bigBtn secondary" id="btnListen">üéß Listen</button>
        </div>
      </div>
    </div>
  </div>
</div>
`;

  document.getElementById("detailsBack").onclick = appBack;
  document.getElementById("detailsBookmark").onclick = ()=>alert("–ó–∞–∫–ª–∞–¥–∫–∏ –¥–æ–¥–∞–º–æ –ø—ñ–∑–Ω—ñ—à–µ.");

  const src = document.getElementById("dSourceLang");
  const trg = document.getElementById("dTargetLang");

  SOURCE_LANGS.forEach(l=>{
    const opt = document.createElement("option");
    opt.value = l.code;
    opt.textContent = flagFor(l.code) + " " + l.label;
    src.appendChild(opt);
  });
  TARGET_LANGS.forEach(l=>{
    const opt = document.createElement("option");
    opt.value = l.code;
    opt.textContent = flagFor(l.code) + " " + l.label;
    trg.appendChild(opt);
  });

  src.value = state.reading.sourceLang || "en";
  trg.value = state.reading.targetLang || "uk";

const bookLabel = document.getElementById("detailsBookLangLabel");
const transLabel = document.getElementById("detailsTransLangLabel");
const bookFlag = document.getElementById("detailsBookFlag");
const transFlag = document.getElementById("detailsTransFlag");
function setLabels(){
  const sOpt = SOURCE_LANGS.find(x=>x.code===src.value);
  const tOpt = TARGET_LANGS.find(x=>x.code===trg.value);
  if(bookLabel && sOpt) bookLabel.textContent = sOpt.label;
  if(transLabel && tOpt) transLabel.textContent = tOpt.label;
  if(bookFlag) bookFlag.textContent = flagFor(src.value);
  if(transFlag) transFlag.textContent = flagFor(trg.value);
}
setLabels();

  src.onchange = ()=>{
    try{ saveReadingProgress(); }catch(e){}
    state.reading.sourceLang = src.value;
    try{ state.reading.translateCache.clear(); }catch(e){}
    setLabels();
    applyLanguagePairChange();
  };

  trg.onchange = ()=>{
    try{ saveReadingProgress(); }catch(e){}
    state.reading.targetLang = trg.value;
    try{ state.reading.translateCache.clear(); }catch(e){}
    setLabels();
    applyLanguagePairChange();
  };

  document.getElementById("btnListen").onclick = ()=>go({name:"reader", bookId: b.id});
  document.getElementById("btnRead").onclick = ()=>go({name:"bireader", bookId: b.id});
}

function renderReader(){
  if(!state.book){ return go({name:"catalog"}, {push:false}); }
  const b = state.book;

  setTheme(state.reading.night);
  syncSettingsUI();
  applyHighlightTheme();

  // Use first heading-like line as screen title if present
  const firstHeading = (b.text || []).find(t=>/^Chapter\s\d+:/i.test(String(t||"")) || /^The\s+/i.test(String(t||""))) || (b.title_en || "");
  const lines = (b.text || []);

  // chapter headings (start indices) for consistent styling across all languages
  const chapterStarts = new Set((getChapters()||[]).map(c=>Number(c.startIndex||0)).filter(n=>Number.isFinite(n)));

  app.innerHTML = `
    <div class="listenStage">
      <div class="listenTop">
        <div class="ltLeft">
          <button class="chevBtn" id="btnBooks" aria-label="Books">‚â°</button>
          <button class="chevBtn" id="readerBack" aria-label="Back">‚Äπ</button>
        </div>
        <div class="ltCenter">${escapeHtml(b.title_en || "Book")}</div>
        <div class="ltRight">
          <button class="topIcon" id="topBookmarks" title="Bookmarks">üîñ</button>
          <button class="topIcon" id="topDev" title="Admin">‚ãØ</button>
          <button class="topIcon" id="topSettings" title="Settings">‚öôÔ∏é</button>
        </div>
      </div>

      <div class="listenTitle">${escapeHtml(String(firstHeading || ""))}</div>

      <div class="listenList">
        ${lines.map((p, i)=>{
          const raw = String(p ?? "");
          const isCh = chapterStarts.has(i);
          // keep empty lines as spacer
          if(raw === ""){
            return `<div style="height:10px"></div>`;
          }
          return `
            <div class="listenLine ${isCh ? "chapterLine" : ""}" data-para-wrap="${i}">
              ${renderParagraph(raw, i, isCh)}
              <button class="lineCardBtn" data-para-btn="${i}" title="Line translation">
                <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M7 8h10M7 12h6M7 16h8" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
              </button>
            </div>
          `;
        }).join("")}
      </div>
    </div>
  `;

  document.getElementById("readerBack").onclick = appBack;
  const __books = document.getElementById("btnBooks");
  if(__books) __books.onclick = goCatalog;

  // Important: stop propagation so the global "outside click" handler
  // doesn't instantly close the sheet right after it opens.
  const __ts = document.getElementById("topSettings");
  if(__ts){
    __ts.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      try{ openSettings(); }catch(err){}
    });
  }
  const __td = document.getElementById("topDev");
  if(__td){
    __td.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      try{ openDev(); }catch(err){}
    });
  }

  // Quick open Bookmarks
  const __tbm = document.getElementById("topBookmarks");
  if(__tbm){
    __tbm.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      try{ stopReading(); }catch(err){}
      state.ui = state.ui || {};
      state.ui.libraryTab = "bookmarks";
      go({name:"library"}, {push:true});
    });
  }

  document.documentElement.style.setProperty("--fontSize", state.reading.fontSize + "px");
  document.documentElement.style.setProperty("--lineHeight", "1.9");

  buildTokenMap();
  buildParaWordMap();

  // If we navigated here from a bookmark, jump to that paragraph
  try{
    if(state.route && state.route.startPara != null){
      const sp = Math.max(0, Number(state.route.startPara||0));
      openaiLineIndex = sp;
      state.reading.activeParaIndex = sp;
      state.reading.resumeIndexReader = sp;
      // highlight + scroll
      try{ clearActivePara(); }catch(e){}
      try{ setActivePara(sp); }catch(e){}
      setTimeout(()=>{ try{ scrollToPara(sp); }catch(e){} }, 80);
      // consume once
      try{ delete state.route.startPara; }catch(e){}
    }
  }catch(e){}

  // We do not show inline line translations in Listen UI; but we keep them cached.
  initReaderLineTranslations({silent:true});

  // Line card button
  [...document.querySelectorAll(".lineCardBtn")].forEach(btn=>{
    btn.addEventListener("click",(e)=>{
      e.stopPropagation();
      const idx = Number(btn.dataset.paraBtn);
      showLineCard(idx);
    });
  });

  // close popover on outside click
  document.addEventListener("click", onDocClick, {capture:true});
  updateProgressUI();
}
function renderBiReader(){
  if(!state.book){ return go({name:"catalog"}, {push:false}); }
  const b = state.book;

  setTheme(state.reading.night);
  syncSettingsUI();
  applyHighlightTheme();
  hideTranslation();

  const lines = (b.text || []);
  state.reading.biTotal = lines.length;

  const chapterStarts = new Set((getChapters()||[]).map(c=>Number(c.startIndex||0)).filter(n=>Number.isFinite(n)));

  app.innerHTML = `
    <div class="readerStage">
      <div class="readTopBar">
        <div class="rtLeft">
          <button class="chevBtn" id="btnBooks" aria-label="Books">‚â°</button>
          <button class="chevBtn" id="readerBack" aria-label="Back">‚Äπ</button>
        </div>
        <div class="rtCenter">${escapeHtml(b.title_en || "")}</div>
        <div class="rtRight">
          <button class="topIcon" id="topBookmarks" title="Bookmarks">üîñ</button>
          <button class="topIcon" id="topDev" title="Admin">‚ãØ</button>
          <button class="topIcon" id="topSettings" title="Settings">‚öôÔ∏é</button>
        </div>
      </div>

      <div class="paper">
        <div class="paperInner">
          <div class="bookTitle">${escapeHtml(b.title_en || "")}</div>

          ${lines.map((ln, i)=>{
            const raw = String(ln ?? "");
            const isCh = chapterStarts.has(i);
            if(raw === ""){
              return `<div style="height:14px"></div>`;
            }
            return `
              <div class="paraLine ${isCh ? "chapterLine" : ""}">
                <div class="line" data-token="line" data-idx="${i}" data-raw="${escapeHtml(raw)}" style="${isCh? "font-weight:900;letter-spacing:.2px" : ""}">${escapeHtml(raw)}</div>
                <div class="paraTrans" data-for="${i}"></div>
              </div>
            `;
          }).join("")}
        </div>
      </div>
    </div>
  `;

  document.getElementById("readerBack").onclick = appBack;
  const __books = document.getElementById("btnBooks");
  if(__books) __books.onclick = goCatalog;

  // Stop propagation so global outside-click handler doesn't close immediately.
  const __ts = document.getElementById("topSettings");
  if(__ts){
    __ts.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      try{ openSettings(); }catch(err){}
    });
  }
  const __td = document.getElementById("topDev");
  if(__td){
    __td.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      try{ openDev(); }catch(err){}
    });
  }

  const __tbm = document.getElementById("topBookmarks");
  if(__tbm){
    __tbm.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      try{ stopReading(); }catch(err){}
      state.ui = state.ui || {};
      state.ui.libraryTab = "bookmarks";
      go({name:"library"}, {push:true});
    });
  }

  document.documentElement.style.setProperty("--fontSize", state.reading.fontSize + "px");
  document.documentElement.style.setProperty("--lineHeight", "1.9");

  buildLineMap();
  document.body.classList.toggle("hideLineTrans", !state.reading.lineTranslation);
  document.body.classList.toggle("swapLang", !!state.reading.swapLang);
  initLineTranslations();
  // Safety: when returning to BiReader, Safari can keep empty translations with done=1.
  // If that happens, force a refresh so translations render again without reloading the page.
  if(state.reading.lineTranslation){
    const needsRefresh = [...document.querySelectorAll('.paraTrans[data-for]')]
      .some(el => (el.dataset.done === '1' && (!el.textContent || !el.textContent.trim())));
    if(needsRefresh){
      try{ refreshBiReaderTranslations(); }catch(e){}
    }
  }

}

function buildLineMap(){
  const els = [...document.querySelectorAll('.line[data-token="line"]')];
  state.reading.tokenMap = els;
  state.reading.wordCount = els.length;
}

/* ---------------------------
   Text tokens
--------------------------- */
// Word normalization / tokenization MUST work for:
// - Latin + diacritics (PL/DE/FR/ES)
// - Cyrillic (UK/RU)
// Safari/WebView note: avoid Unicode property escapes (\p{L}) to prevent white screens.
const WORD_CHARS = "0-9A-Za-z\u00C0-\u024F\u1E00-\u1EFF\u0400-\u052F\u2DE0-\u2DFF\uA640-\uA69F'‚Äô";
const WORD_TOKEN_RE = new RegExp(`(\\s+|[${WORD_CHARS}]+|[^\\s])`, "g");
const WORD_ONLY_RE = new RegExp(`^[${WORD_CHARS}]+$`);
const WORD_TRIM_RE = new RegExp(`^[^${WORD_CHARS}]+|[^${WORD_CHARS}]+$`, "g");

function normalizeWord(w){
  return String(w||"")
    .toLowerCase()
    .replace(WORD_TRIM_RE, "");
}

function renderParagraph(text, pIndex, isHeadingOverride=false){
  if(text === ""){
    return `<p class="para" data-para="${pIndex}"><span style="border-bottom-color:transparent;opacity:.35">‚Äî</span></p>`;
  }
  const tokens = String(text).match(WORD_TOKEN_RE) || [String(text)];
  const hText = String(text||"").replace(/\u00A0/g," ").trim();
  const headingKw = /^(chapter|chapitre|kapitel|cap[i√≠]tulo|capitulo|rozdzia[l≈Ç]|rozdzial|—Ä–æ–∑–¥—ñ–ª|–≥–ª–∞–≤–∞|—á–∞—Å—Ç–∏–Ω–∞|part|section)\b/i;
  const isHeading = !!isHeadingOverride || headingKw.test(hText) || (hText.length<=60 && (/[0-9]/.test(hText) || /\b[IVXLCDM]{1,8}\b/i.test(hText)) && !/[.!?]$/.test(hText));

  return `
    <p class="para" data-para="${pIndex}" style="${isHeading ? "font-weight:950;letter-spacing:.2px" : ""}">
      ${tokens.map((t)=>{
        if(/^\s+$/.test(t)) return `<span class="w space" data-token="space"> </span>`;
        const isWord = WORD_ONLY_RE.test(t);
        if(!isWord){
          return `<span class="w" data-token="punct" data-raw="${escapeHtml(t)}" style="border-bottom-color:transparent;cursor:default">${escapeHtml(t)}</span>`;
        }
        const raw = t;
        const key = normalizeWord(raw);
        return `<span class="w" data-token="word" data-key="${escapeHtml(key)}" data-raw="${escapeHtml(raw)}">${escapeHtml(raw)}</span>`;
      }).join("")}
    </p>
  `;
}

function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;");
}

function buildTokenMap(){
  const spans = [...document.querySelectorAll('.w[data-token="word"]')];
  state.reading.tokenMap = spans;
  state.reading.wordCount = spans.length;

  // IMPORTANT: translation only by click/tap to avoid 429
  spans.forEach((sp)=>{
    sp.addEventListener("click", (e)=> {
      if(!state.reading.showTranslation) return;
      e.stopPropagation();
      showTranslation(sp);
    });
  });
}

function buildParaWordMap(){
  // IMPORTANT: map paragraphs by their data-para index (do not rely on DOM order),
  // because we may skip rendering empty lines (spacers) and indices must stay aligned
  // with state.book.text/openaiLineIndex.
  const paras = [...document.querySelectorAll(".para[data-para]")];
  state.reading.paras = [];
  state.reading.paraWords = [];
  paras.forEach(p=>{
    const idx = Number(p.dataset.para);
    state.reading.paras[idx] = p;
    state.reading.paraWords[idx] = [...p.querySelectorAll('.w[data-token="word"]')];
  });
}


function clearActivePara(){
  const prev = state.reading.activeParaIndex;
  try{
    if(prev != null && prev >= 0){
      // remove paragraph highlight
      if(state.reading.paras && state.reading.paras[prev]){
        state.reading.paras[prev].classList.remove("activeLine");
      }
      // remove any lingering word highlight
      clearParaWordHighlight(prev);
    }
  }catch(e){}
  state.reading.activeParaIndex = -1;
}

function setActivePara(idx){
  // IMPORTANT: active index must update even when highlight is disabled
  idx = Number(idx);
  if(!Number.isFinite(idx) || idx < 0) idx = 0;

  if(!state.reading.highlight){
    // keep state updated even when highlight is disabled
    state.reading.activeParaIndex = idx;
    // still keep the current paragraph in view
    try{ scrollToPara(idx); }catch(e){}
    return;
  }
  if(idx === state.reading.activeParaIndex) return;

  clearActivePara();

  const p = state.reading.paras && state.reading.paras[idx];
  if(p){
    p.classList.add("activeLine");
    state.reading.activeParaIndex = idx;

    const r = p.getBoundingClientRect();
    const topZone = window.innerHeight * 0.20;
    const botZone = window.innerHeight * 0.80;
    if(r.top < topZone || r.bottom > botZone){
      window.scrollBy({top: (r.top - window.innerHeight/2), behavior:"smooth"});
    }
  }
}

// In Listen mode we sometimes want ONLY word highlight (no paragraph block highlight),
// but still need auto-scroll to the current paragraph.
function scrollToPara(idx){
  const p = state.reading.paras && state.reading.paras[idx];
  if(!p) return;
  const r = p.getBoundingClientRect();
  const topZone = window.innerHeight * 0.20;
  const botZone = window.innerHeight * 0.80;
  if(r.top < topZone || r.bottom > botZone){
    window.scrollBy({top: (r.top - window.innerHeight/2), behavior:"smooth"});
  }
}

function scrollToLine(idx){
  const el = document.querySelector(`.line[data-idx="${idx}"]`);
  if(!el) return;
  const r = el.getBoundingClientRect();
  window.scrollBy({top: (r.top - window.innerHeight/3), behavior:'smooth'});
}


function clearParaWordHighlight(paraIdx){
  const list = state.reading.paraWords?.[paraIdx] || [];
  list.forEach(sp=>sp.classList.remove("active"));
}

function setActiveParaWord(paraIdx, wordIdx){
  if(!state.reading.highlight) return;
  const list = state.reading.paraWords?.[paraIdx] || [];
  if(!list.length) return;
  list.forEach(sp=>sp.classList.remove("active"));
  const sp = list[wordIdx];
  if(sp) sp.classList.add("active");
}


// Universal word highlight for AUDIO playback (OpenAI / any mp3). Works on iOS too.
let __hlRaf = 0;
function stopAudioWordHighlight(){
  if(__hlRaf) cancelAnimationFrame(__hlRaf);
  __hlRaf = 0;
}
function startAudioWordHighlight({ audio, paraIdx, text, mode, spans }){
  stopAudioWordHighlight();
  if(mode !== "reader") return;
  if(!state.reading.highlight) return;
  if(!audio) return;

  const words = [...String(text).matchAll(new RegExp(`[${WORD_CHARS}]+`, 'g'))].map(m => m[0]);
  if(!words.length) return;

  const sps = spans || (state.reading.paraWords?.[paraIdx] || []);
  if(!sps.length) return;

  function buildTimeline(duration){
    const w = words.map(x => Math.max(1, x.length));
    const sum = w.reduce((a,b)=>a+b,0);
    const t = [];
    let acc = 0;
    for(let i=0;i<w.length;i++){
      acc += w[i];
      t.push((acc / sum) * duration); // end time of word i
    }
    return t;
  }

  let timeline = null;
  let lastIdx = -1;

  const tick = ()=>{
    if(!state.reading.isPlaying){ stopAudioWordHighlight(); return; }
    if(!audio || audio.paused){ __hlRaf = requestAnimationFrame(tick); return; }

    const dur = audio.duration;
    if(!timeline && Number.isFinite(dur) && dur > 0){
      timeline = buildTimeline(dur);
    }

    if(timeline){
      const ct = audio.currentTime;
      let i = timeline.findIndex(x => x >= ct);
      if(i < 0) i = timeline.length - 1;
      i = Math.min(i, sps.length - 1);
      if(i !== lastIdx){
        setActiveParaWord(paraIdx, i);
        lastIdx = i;
      }
    }
    __hlRaf = requestAnimationFrame(tick);
  };

  __hlRaf = requestAnimationFrame(tick);

  audio.addEventListener("ended", stopAudioWordHighlight, { once:true });
}


function langToLocale(code){
  const c = String(code||"").toLowerCase();
  if(c==="uk") return "uk-UA";
  if(c==="ru") return "ru-RU";
  if(c==="pl") return "pl-PL";
  if(c==="de") return "de-DE";
  if(c==="es") return "es-ES";
  if(c==="fr") return "fr-FR";
  return "en-US";
}


/* ---------------------------
   Translation (LibreTranslate) + 429 protection
--------------------------- */
async function translateWord(word){
  const clean = normalizeWord(word);
  if(!clean) return "‚Äî";

  const cacheKey = `${state.reading.targetLang}|${clean}`;
  if(state.reading.translateCache.has(cacheKey)) return state.reading.translateCache.get(cacheKey);

  const now = Date.now();

  // cooldown after 429
  if(now < (state.reading.cooldownUntil || 0)){
    const sec = Math.max(1, Math.ceil((state.reading.cooldownUntil - now)/1000));
    return `‚è≥ –õ—ñ–º—ñ—Ç –ø–µ—Ä–µ–∫–ª–∞–¥—É. –°–ø—Ä–æ–±—É–π —á–µ—Ä–µ–∑ ${sec}s.`;
  }

  // block parallel requests
  if(state.reading.inFlight){
    return "‚Ä¶";
  }

  // throttle: min 700ms between requests
  if(now - (state.reading.lastReqAt || 0) < 700){
    return "‚Ä¶";
  }

  state.reading.inFlight = true;
  state.reading.lastReqAt = now;

  const payload = {
    q: clean,
    source: "auto",
    target: state.reading.targetLang || "uk",
    format: "text",
    alternatives: 3,
    api_key: LIBRETRANSLATE_API_KEY || ""
  };

  try{
    const res = await fetch(LIBRETRANSLATE_URL, {
      method:"POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });

    if(res.status === 429){
      state.reading.cooldownUntil = Date.now() + 20000; // 20s pause
      return "‚è≥ –õ—ñ–º—ñ—Ç –ø–µ—Ä–µ–∫–ª–∞–¥—É. –ó–∞—á–µ–∫–∞–π 20 —Å–µ–∫—É–Ω–¥.";
    }

    if(!res.ok){
      return `‚Äî (–ø–æ–º–∏–ª–∫–∞ ${res.status})`;
    }

    const data = await res.json().catch(()=> ({}));
    const translated = data.translatedText || "‚Äî";
    state.reading.translateCache.set(cacheKey, translated);
    return translated;
  }catch(e){
    return "‚Äî (–Ω–µ –≤–¥–∞–ª–æ—Å—è –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è)";
  }finally{
    state.reading.inFlight = false;
  }
}

async function translateTextAny(text){
  const s = String(text || "").trim();
  if(!s) return "";

  const cacheKey = `LINE|${state.dev.translationProvider}|${state.reading.targetLang}|${s}`;
  if(state.reading.translateCache.has(cacheKey)) return state.reading.translateCache.get(cacheKey);

  const now = Date.now();
  if(now < (state.reading.cooldownUntil || 0)){
    const sec = Math.max(1, Math.ceil((state.reading.cooldownUntil - now)/1000));
    return `‚è≥ –õ—ñ–º—ñ—Ç –ø–µ—Ä–µ–∫–ª–∞–¥—É. –°–ø—Ä–æ–±—É–π —á–µ—Ä–µ–∑ ${sec}s.`;
  }
  if(state.reading.inFlight) return "‚Ä¶";
  if(now - (state.reading.lastReqAt || 0) < 900) return "‚Ä¶";

  state.reading.inFlight = true;
  state.reading.lastReqAt = now;

  try{
    if(state.dev.translationProvider === "openai"){
      const url = String(WORKER_TRANSLATE_URL || "").trim();
      if(!url) return "‚Äî (Worker URL –Ω–µ –∑–∞–¥–∞–Ω–æ)";

      const res = await fetch(url, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({text: s, target: state.reading.targetLang || "uk", noCache: !!state.dev.noCache})
      });

      if(res.status === 429){
        state.reading.cooldownUntil = Date.now() + 20000;
        return "‚è≥ –õ—ñ–º—ñ—Ç. –ó–∞—á–µ–∫–∞–π 20 —Å–µ–∫—É–Ω–¥.";
      }
      if(!res.ok) return `‚Äî (–ø–æ–º–∏–ª–∫–∞ ${res.status})`;

      const data = await res.json().catch(()=> ({}));
      const translated = (data.translatedText || "").trim() || "‚Äî";
      state.reading.translateCache.set(cacheKey, translated);
      return translated;
    }

    const payload = {q: s, source: "auto", target: state.reading.targetLang || "uk", format: "text", api_key: LIBRETRANSLATE_API_KEY || ""};
    const res = await fetch(LIBRETRANSLATE_URL, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(payload)});

    if(res.status === 429){
      state.reading.cooldownUntil = Date.now() + 20000;
      return "‚è≥ –õ—ñ–º—ñ—Ç –ø–µ—Ä–µ–∫–ª–∞–¥—É. –ó–∞—á–µ–∫–∞–π 20 —Å–µ–∫—É–Ω–¥.";
    }
    if(!res.ok) return `‚Äî (–ø–æ–º–∏–ª–∫–∞ ${res.status})`;

    const data = await res.json().catch(()=> ({}));
    const translated = data.translatedText || "‚Äî";
    state.reading.translateCache.set(cacheKey, translated);
    return translated;
  }catch(e){
    return "‚Äî (–Ω–µ –≤–¥–∞–ª–æ—Å—è –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è)";
  }finally{
    state.reading.inFlight = false;
  }
}


let lineObserver = null;
let biProgressObserver = null;

function initLineTranslations(){
  const isBi = state.route?.name === "bireader";
  if(!isBi) return;

  const lines = [...document.querySelectorAll('.line[data-token="line"]')];
  if(!lines.length) return;

  // If translations are hidden, do nothing.
  if(!state.reading.lineTranslation) return;

  // Sequential queue to avoid "random" + avoid global inFlight conflicts.
  // reset queue every time we enter Reader (Safari may keep stale state)
  state.reading._lineQueue = [];
  state.reading._lineQueued = new Set();
  state.reading._lineQueueRunning = false;

  // fix: if Safari left done=1 but empty, allow re-fetch
  const transEls = [...document.querySelectorAll('.paraTrans[data-for]')];
  transEls.forEach(el=>{
    if(el.dataset.done === "1" && !String(el.textContent||"").trim()){
      el.dataset.done = "0";
    }
  });

  function enqueue(idx){
    if(state.reading._lineQueued.has(idx)) return;
    state.reading._lineQueued.add(idx);
    state.reading._lineQueue.push(Number(idx));
    state.reading._lineQueue.sort((a,b)=>a-b);
    runQueue();
  }

  async function runQueue(){
    if(state.reading._lineQueueRunning) return;
    state.reading._lineQueueRunning = true;
    try{
      while(state.reading._lineQueue.length){
        const idx = state.reading._lineQueue.shift();
        const transEl = document.querySelector(`.paraTrans[data-for="${idx}"]`);
        const lineEl = document.querySelector(`.line[data-idx="${idx}"]`);
        if(!transEl || !lineEl) continue;
        if(transEl.dataset.done === "1") continue;

        transEl.textContent = "–ü–µ—Ä–µ–∫–ª–∞–¥‚Ä¶";
        transEl.classList.add("loading");

        const tr = await translateTextAny(lineEl.dataset.raw || "");
        transEl.classList.remove("loading");

        // If throttled placeholder returned, re-queue later
        if(tr === "‚Ä¶" || tr === ""){
          transEl.textContent = "‚Ä¶";
          transEl.dataset.done = "0";
          state.reading._lineQueued.delete(idx);
          // small retry delay
          setTimeout(()=>enqueue(idx), 800);
          continue;
        }

        transEl.textContent = tr;
        transEl.dataset.done = "1";
      }
    }finally{
      state.reading._lineQueueRunning = false;
    }
  }

  if(lineObserver) lineObserver.disconnect();

  lineObserver = new IntersectionObserver((entries)=>{
    for(const en of entries){
      if(!en.isIntersecting) continue;
      const idx = Number(en.target.dataset.idx);
      const transEl = document.querySelector(`.paraTrans[data-for="${idx}"]`);
      if(!transEl || transEl.dataset.done === "1") continue;
      enqueue(idx);
    }
  }, {root:null, threshold:0.25});

  lines.forEach(el=>lineObserver.observe(el));
}







function initReaderLineTranslations({silent=false}={}){
  const isReader = state.route?.name === "reader";
  if(!isReader) return;

  const lines = [...document.querySelectorAll('.line[data-token="line"]')];
  if(!lines.length) return;

  if(!state.reading.lineTranslation) return;

  // reset queue every time we enter Reader (Safari may keep stale state)
  state.reading._lineQueue = [];
  state.reading._lineQueued = new Set();
  state.reading._lineQueueRunning = false;

  // fix: if Safari left done=1 but empty, allow re-fetch
  const __transEls = [...document.querySelectorAll(".paraTrans[data-for]")];
  __transEls.forEach(el=>{
    if(el.dataset.done === "1" && !String(el.textContent||"").trim()){
      el.dataset.done = "0";
    }
  });

  function enqueue(idx){
    if(state.reading._lineQueued.has(idx)) return;
    state.reading._lineQueued.add(idx);
    state.reading._lineQueue.push(Number(idx));
    runQueue();
  }

  async function runQueue(){
    if(state.reading._lineQueueRunning) return;
    state.reading._lineQueueRunning = true;
    try{
      while(state.reading._lineQueue.length){
        const idx = state.reading._lineQueue.shift();
        const lineEl = document.querySelector(`.line[data-token="line"][data-idx="${idx}"]`);
        const transEl = document.querySelector(`.paraTrans[data-for="${idx}"]`);
        if(!lineEl || !transEl) continue;
        if(transEl.dataset.done === "1") continue;

        const raw = (lineEl.dataset.raw || lineEl.textContent || "").trim();
        if(!raw){ transEl.textContent = ""; transEl.dataset.done="1"; continue; }

        const tr = await translateTextAny(raw);
        transEl.textContent = tr || "‚Äî";
        transEl.dataset.done = "1";
      }
    }finally{
      state.reading._lineQueueRunning = false;
    }
  }

  try{ if(lineObserver) lineObserver.disconnect(); }catch(e){}

  lineObserver = new IntersectionObserver((entries)=>{
    for(const en of entries){
      if(!en.isIntersecting) continue;
      const idx = Number(en.target.dataset.idx);
      const transEl = document.querySelector(`.paraTrans[data-for="${idx}"]`);
      if(!transEl || transEl.dataset.done === "1") continue;
      enqueue(idx);
    }
  }, {root:null, threshold:0.25});

  lines.forEach(el=>lineObserver.observe(el));
}

function attachLineTranslationObserver(){
  if(state.route?.name === "bireader") return initLineTranslations();
  if(state.route?.name === "reader") return initReaderLineTranslations();
}
function refreshBiReaderTranslations(){
  if(state.route?.name !== "bireader") return;
  // Clear visible translations and done flags so they can be re-fetched
  const trans = [...document.querySelectorAll('.paraTrans[data-for]')];
  trans.forEach(el=>{
    el.textContent = "";
    el.dataset.done = "0";
    el.classList.remove("loading");
  });
  // reset queue state
  state.reading._lineQueue = [];
  state.reading._lineQueued = new Set();
  state.reading._lineQueueRunning = false;
  try{ if(lineObserver) lineObserver.disconnect(); }catch(e){}
  initLineTranslations();
}

async function showTranslation(span){
  const raw = span.dataset.raw || "";
  popWord.textContent = raw;

  // prepare bookmark context (word inside a paragraph)
  try{
    const pEl = span.closest(".para[data-para]");
    const pIdx = pEl ? Number(pEl.dataset.para) : 0;
    popCtx = { bookId: state.book?.id || state.route?.bookId, paraIdx: Number.isFinite(pIdx) ? pIdx : 0, raw, tr: "" };
  }catch(e){ popCtx = { bookId: state.book?.id || state.route?.bookId, paraIdx: 0, raw, tr:"" }; }

  // Listen mode: pause narration while popover is open
  try{
    if(state.route?.name === "reader" && state.book && state.reading.isPlaying){
      // pause current narration while popover is open
      if(state.dev.ttsProvider === "openai"){
        try{ if(openaiAudio && !openaiAudio.paused){ state.reading.wasPlayingBeforePopover = true; state.reading.pausedForPopover = true; openaiAudio.pause(); } }catch(e){}
      }else if(("speechSynthesis" in window)){
      // pause only if not already paused
      if(!window.speechSynthesis.paused){
        state.reading.wasPlayingBeforePopover = true;
        state.reading.pausedForPopover = true;
        window.speechSynthesis.pause();
      }
    }
  }
  }catch(e){}


  popTrans.textContent = "–ü–µ—Ä–µ–∫–ª–∞–¥‚Ä¶";
  popTrans.classList.add("loading");

  const r = span.getBoundingClientRect();

  // Place popover BELOW the tapped word so it doesn't cover the word/line.
  // If there isn't enough space below, fall back to above.
  const popW = 340;
  // show hidden to measure height
  popover.style.display = "block";
  popover.style.visibility = "hidden";
  popover.style.left = "12px";
  popover.style.top = "12px";
  popover.setAttribute("aria-hidden","false");

  const ph = popover.offsetHeight || 180;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const x = Math.min(vw - popW - 12, Math.max(12, r.left));
  let y = Math.round(r.bottom); // top edge aligned to tapped word bottom
  if(y + ph + 12 > vh){
    y = Math.max(12, Math.round(r.top) - ph);
  }
  popover.style.left = x + "px";
  popover.style.top = y + "px";
  popover.style.visibility = "visible";

  const tr = await translateWord(raw);
  popTrans.classList.remove("loading");
  popTrans.textContent = tr;
  try{ if(popCtx) popCtx.tr = tr; }catch(e){}
  try{ if(popCtx) popCtx.tr = tr; }catch(e){}

  popSpeak.onclick = ()=>playOneShotTTS(raw);
  popPlayFromHere.onclick = ()=>{
    const pEl = span.closest(".para[data-para]");
    const pIdx = pEl ? Number(pEl.dataset.para) : 0;
    openaiLineIndex = Math.max(0, pIdx);
    state.reading.activeParaIndex = openaiLineIndex;
    clearActivePara();
    setActivePara(openaiLineIndex);
    startReadingOpenAI({mode:"reader", speakTranslation:false});
    hideTranslation();
  };
}


let oneShotAudio = null;
let oneShotUrl = null;

async function playOneShotTTS(text){
  const t = String(text||"").trim();
  if(!t) return;
  try{
    if(oneShotAudio){ try{ oneShotAudio.pause(); }catch(e){} }
    if(oneShotUrl){ try{ URL.revokeObjectURL(oneShotUrl); }catch(e){} }
  }catch(e){}
  const voice = state.dev.ttsVoice || (state.dev.ttsGender === "female" ? "shimmer" : "onyx");
  const instructions = state.dev.ttsInstructions || "";
  const speed = state.reading.speed;
  let blob;
  try{
    blob = await fetchTtsAudioBlob(t, {voice, instructions, speed, noCache: state.dev.noCache});
  }catch(e){
    console.warn(e);
    return;
  }
  oneShotUrl = URL.createObjectURL(blob);
  oneShotAudio = new Audio(oneShotUrl);
  oneShotAudio.onended = ()=>{ try{ URL.revokeObjectURL(oneShotUrl);}catch(e){} oneShotUrl=null; };
  try{ await oneShotAudio.play(); }catch(e){ /* ignore */ }
}
async function translateLine(text){
  // Line-level translation uses the same engine/cache as other translations
  return await translateTextAny(String(text||""));
}

async function showLineCard(paraIdx){
  if(!state.book) return;
  const b = state.book;
  const raw = String((b.text||[])[paraIdx] ?? "");
  if(!raw) return;

  // prepare bookmark context (line)
  try{ popCtx = { bookId: b.id || state.route?.bookId, paraIdx: Number.isFinite(paraIdx) ? Number(paraIdx) : 0, raw, tr: "" }; }catch(e){ popCtx = { bookId: b.id || state.route?.bookId, paraIdx: 0, raw, tr: "" }; }

  // Pause narration while popover is open
  try{ if(state.reading.isPlaying && openaiAudio && !openaiAudio.paused){ state.reading.wasPlayingBeforePopover=true; state.reading.pausedForPopover=true; openaiAudio.pause(); } }catch(e){}

  popWord.textContent = raw;
  popTrans.textContent = "–ü–µ—Ä–µ–∫–ª–∞–¥‚Ä¶";
  popTrans.classList.add("loading");

  // Place popover BELOW the tapped line so it doesn't cover the line.
  const wrap = document.querySelector(`[data-para-wrap="${paraIdx}"]`);
  const r = wrap ? wrap.getBoundingClientRect() : {left:12, top:120, bottom:140};
  const popW = 360;
  // show hidden to measure height
  popover.style.display = "block";
  popover.style.visibility = "hidden";
  popover.style.left = "12px";
  popover.style.top = "12px";
  popover.setAttribute("aria-hidden","false");

  const ph = popover.offsetHeight || 240;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const x = Math.min(vw - popW - 12, Math.max(12, r.left));
  let y = Math.round(r.bottom);
  if(y + ph + 12 > vh){
    y = Math.max(12, Math.round(r.top) - ph);
  }
  popover.style.left = x + "px";
  popover.style.top = y + "px";
  popover.style.visibility = "visible";

  const tr = await translateLine(raw);
  popTrans.classList.remove("loading");
  popTrans.textContent = tr;
  try{ if(popCtx) popCtx.tr = tr; }catch(e){}
  try{ if(popCtx) popCtx.tr = tr; }catch(e){}

  popSpeak.onclick = ()=>playOneShotTTS(raw);

  popPlayFromHere.onclick = ()=>{
    openaiLineIndex = Math.max(0, paraIdx);
    state.reading.activeParaIndex = openaiLineIndex;
    clearActivePara();
    setActivePara(openaiLineIndex);
    startReadingOpenAI({mode:"reader", speakTranslation:false});
    hideTranslation();
  };
}


function hideTranslation(){
  popover.style.display = "none";
  popCtx = null;

  // Resume narration after closing popover (if we paused it)
  try{
    if(state.route?.name === "reader"
      && state.reading.pausedForPopover
      && state.reading.wasPlayingBeforePopover
      && state.reading.isPlaying){

      if(state.dev.ttsProvider === "openai"){
        try{ if(openaiAudio && openaiAudio.paused){ openaiAudio.play(); } }catch(e){}
      }else if(("speechSynthesis" in window) && window.speechSynthesis.paused){
        window.speechSynthesis.resume();
      }
    }
  }catch(e){}

  state.reading.pausedForPopover = false;
  state.reading.wasPlayingBeforePopover = false;
}

function onDocClick(e){
  if(!popover.contains(e.target)) hideTranslation();
}


/* ---------------------------
   Active line helpers (Bi-reader)
--------------------------- */
let activeLineEl = null;
let activeTransEl = null;

function clearActiveLineUI(){
  try{
    if(activeLineEl) activeLineEl.classList.remove("activeLine");
    if(activeTransEl) activeTransEl.classList.remove("activeTrans");
  }catch(e){}
  activeLineEl = null;
  activeTransEl = null;
}

function setActiveLineUI(idx){
  // Works only in Bi-reader (line-by-line mode)
  idx = Number(idx);
  if(!Number.isFinite(idx) || idx < 0) idx = 0;

  // IMPORTANT: active index must update even when highlight is disabled
  state.reading.activeBiLineIndex = idx;
  // progress for Bi-reader
  const total = Number(state.reading.biTotal||state.reading.wordCount||0);
  if(total>0){ state.reading.progress = (idx+1)/total; updateProgressUI(); }

  if(!state.reading.highlight){
    try{ scrollToLine(idx); }catch(e){}
    return;
  }
  clearActiveLineUI();

  const lineEl = document.querySelector(`.line[data-idx="${idx}"]`);
  if(!lineEl) return;

  const transEl = document.querySelector(`.paraTrans[data-for="${idx}"]`);
  // In Bi-reader we want two-line highlight:
  // Top (spoken) line = strong highlight, other line = softer.
  // swapLang=true => spoken is translation.
  const speakTranslation = !!state.reading.swapLang;

  if(!speakTranslation){
    // Spoken: original line
    activeLineEl = lineEl;
    activeTransEl = transEl || null;
    lineEl.classList.add("activeLine");
    if(transEl) transEl.classList.add("activeTrans");
  }else{
    // Spoken: translation line
    activeLineEl = transEl || null;
    activeTransEl = lineEl;
    if(transEl) transEl.classList.add("activeLine");
    lineEl.classList.add("activeTrans");
  }

  // Gentle scroll to keep active line visible
  const scrollEl = (speakTranslation && transEl) ? transEl : lineEl;
  const r = scrollEl.getBoundingClientRect();
  const topZone = window.innerHeight * 0.25;
  const botZone = window.innerHeight * 0.75;
  if(r.top < topZone || r.bottom > botZone){
    window.scrollBy({top: (r.top - window.innerHeight/2), behavior:"smooth"});
  }
}

// Back-compat: older code calls setActiveLine()
function setActiveLine(idx){
  return setActiveLineUI(idx);
}

// Back-compat in case older code calls clearActiveLine()
function clearActiveLine(){ clearActiveLineUI(); }

/* ---------------------------
   Audio unlock (iOS/Safari)
--------------------------- */
let __audioUnlocked = false;
function ensureAudioUnlocked(){
  if(__audioUnlocked) return;
  __audioUnlocked = true;
  try{
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if(!AudioCtx) return;
    const ctx = new AudioCtx();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    g.gain.value = 0;
    o.connect(g);
    g.connect(ctx.destination);
    o.start();
    o.stop(ctx.currentTime + 0.01);
    if(ctx.resume) ctx.resume();
  }catch(e){}
}

function startReading(){
  // OpenAI-only narration
  startReadingOpenAI();
}

// ===== OpenAI TTS (line-by-line, cached in Worker) =====
let openaiAudio = null;
let openaiSessionId = 0;
let openaiLineIndex = 0;
let openaiStopRequested = false;

function getListenLines(){
  return (state.book?.text || []).map(s=>String(s ?? ""));
}

// If the worker caches by (text, voice) only, speed changes may appear to do nothing.
// We can safely bypass cache whenever speed differs from the stored "Normal" speed.
function shouldBypassTtsCache(speed){
  const s = Number(speed);
  const normal = Number.isFinite(state.reading.normalSpeed)
    ? Number(state.reading.normalSpeed)
    : Number(state.reading.speed);
  if(!Number.isFinite(s) || !Number.isFinite(normal)) return false;
  return Math.abs(s - normal) > 0.01;
}

async function fetchTtsAudioBlob(text, {voice, instructions, speed, noCache=false}={}){
  const url = String(WORKER_TTS_URL || "").trim();
  if(!url) throw new Error("WORKER_TTS_URL is empty");
  const effectiveNoCache = !!noCache || !!state?.dev?.noCache || shouldBypassTtsCache(speed);
  const res = await fetch(url, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({text, voice, instructions, speed, format: "mp3", noCache: effectiveNoCache})
  });
  if(!res.ok){
    const t = await res.text().catch(()=>"");
    throw new Error(`TTS error ${res.status}: ${t}`);
  }
  const ab = await res.arrayBuffer();
  return new Blob([ab], {type:"audio/mpeg"});
}


async function startReadingOpenAI(){
  stopReading();
  ensureAudioUnlocked();
  state.reading.isPlaying = true;
  btnPlay.textContent = "‚è∏";
  hideTranslation();

  openaiStopRequested = false;
  const thisSession = (++openaiSessionId);
  // resume index depends on mode
  const mode = state.route?.name;
  if(mode === "bireader"){
    openaiLineIndex = Number.isFinite(state.reading.resumeIndexBi) ? state.reading.resumeIndexBi : (Number.isFinite(state.reading.activeBiLineIndex)? state.reading.activeBiLineIndex : 0);
  }else{
    openaiLineIndex = Number.isFinite(state.reading.resumeIndexReader) ? state.reading.resumeIndexReader : (Number.isFinite(state.reading.activeParaIndex)? state.reading.activeParaIndex : 0);
  }
  // mode already computed above
  const lines = getListenLines();

  const useTranslation = ()=>{
    if(mode === "reader") return (state.reading.listenMode === "translation");
    return !!state.reading.swapLang;
  };

  
  // Prefetch cache for seamless autoplay (iOS/WebView can block play() after awaits)
  const ttsPrefetch = new Map(); // idx -> Promise<Blob>

  function findNextNonEmpty(startIdx){
    for(let i=startIdx;i<lines.length;i++){
      const t = String(lines[i] ?? "").trim();
      if(t) return i;
    }
    return -1;
  }

  function prefetchForIndex(idx){
    if(idx < 0 || idx >= lines.length) return;
    if(ttsPrefetch.has(idx)) return;

    const speakTr = useTranslation();
    const line = String(lines[idx] ?? "").trim();
    if(!line) return;

    const voice = state.dev.ttsVoice || (state.dev.ttsGender === "female" ? "shimmer" : "onyx");
    const instructions = state.dev.ttsInstructions || "";
    const speed = state.reading.speed;

    const p = (async ()=>{
      let speakText = line;
      if(speakTr){
        try{
          const tr = await translateTextAny(line);
          if(tr && tr !== "‚Äî" && tr !== "‚Ä¶") speakText = tr;
        }catch(e){}
      }
      return await fetchTtsAudioBlob(speakText, {voice, instructions, speed, noCache: state.dev.noCache});
    })();

    ttsPrefetch.set(idx, p);
  }
const playNext = async ()=>{
    if(openaiStopRequested || !state.reading.isPlaying) return;

    // Skip empty lines (chapter gaps) without pausing
    openaiLineIndex = findNextNonEmpty(openaiLineIndex);
    if(openaiLineIndex === -1 || openaiLineIndex >= lines.length){ finishReading(); return; }

    const raw = String(lines[openaiLineIndex] ?? "");
    const lineText = raw.trim();

    const speakTr = useTranslation();
    let speakText = lineText;

    if(speakTr){
      const tr = await translateTextAny(lineText);
      if(tr && tr !== "‚Äî" && tr !== "‚Ä¶") speakText = tr;
    }

    // Highlight:
    // - Listen mode (reader): word highlight only (no full paragraph block)
    // - Read mode (bireader): line highlight (two rows)
    if(mode === "reader"){
      setActivePara(openaiLineIndex);
      scrollToPara(openaiLineIndex);
    }else{
      setActiveLineUI(openaiLineIndex);
    }

    // Progress is line-based for OpenAI narration
    try{
      const total = lines.length || 0;
      if(total > 0){
        state.reading.progress = (openaiLineIndex + 1) / total;
        updateProgressUI();
      }
    }catch(e){}

    const voice = state.dev.ttsVoice || (state.dev.ttsGender === "female" ? "shimmer" : "onyx");
    const instructions = state.dev.ttsInstructions || "";
    const speed = state.reading.speed;

    // Use prefetched TTS when available (important for iOS autoplay)
    let blob;
    try{
      const pref = ttsPrefetch.get(openaiLineIndex);
      if(pref){
        ttsPrefetch.delete(openaiLineIndex);
        blob = await pref;
      }else{
        blob = await fetchTtsAudioBlob(speakText, {voice, instructions, speed, noCache: state.dev.noCache});
      }
    }catch(err){
      console.warn(err);
      openaiLineIndex += 1;
      // continue immediately (also skips blanks at top of loop)
      playNext();
      return;
    }


    if(openaiStopRequested || !state.reading.isPlaying || thisSession !== openaiSessionId) return;

    if(openaiAudio){
      try{ openaiAudio.pause(); }catch(e){}
      openaiAudio = null;
    }

    const objUrl = URL.createObjectURL(blob);
    openaiAudio = new Audio(objUrl);
    // Prefetch next playable line to avoid iOS pausing after a single line
    prefetchForIndex(findNextNonEmpty(openaiLineIndex + 1));

// Word highlight only when we're speaking ORIGINAL (so spans match original text)
if(mode === "reader" && !speakTr && state.reading.highlight){
  const startHL = ()=>{
    startAudioWordHighlight({
      audio: openaiAudio,
      paraIdx: openaiLineIndex,
      text: lineText,
      mode
    });
  };
  openaiAudio.addEventListener("loadedmetadata", startHL, { once:true });
  // if metadata is already available
  if(Number.isFinite(openaiAudio.duration) && openaiAudio.duration > 0) startHL();
}

    openaiAudio.onended = ()=>{
      stopAudioWordHighlight();
      URL.revokeObjectURL(objUrl);
      if(openaiStopRequested || !state.reading.isPlaying || thisSession !== openaiSessionId) return;
      openaiLineIndex += 1;
      // persist resume for this mode
      if(mode === "bireader") state.reading.resumeIndexBi = openaiLineIndex; else state.reading.resumeIndexReader = openaiLineIndex;
      playNext();
    };
    openaiAudio.onerror = ()=>{
      stopAudioWordHighlight();
      URL.revokeObjectURL(objUrl);
      // Don't skip ahead on audio errors; pause so user can retry.
      if(openaiStopRequested || thisSession !== openaiSessionId) return;
      state.reading.isPlaying = false;
      btnPlay.textContent = "‚ñ∂";
      return;
    };

    try{
      if(openaiStopRequested || !state.reading.isPlaying || thisSession !== openaiSessionId) return;
      await openaiAudio.play();
    }catch(e){
      // On mobile browsers, play() can be blocked; DO NOT advance the cursor.
      console.warn(e);
      if(openaiStopRequested || thisSession !== openaiSessionId) return;
      state.reading.isPlaying = false;
      btnPlay.textContent = "‚ñ∂";
      stopAudioWordHighlight();
      // keep openaiLineIndex as-is so resume continues from the same line
      return;
    }
  };

  playNext();
}



function startDeterministicHighlight(){
  const n = state.reading.wordCount;
  if(!n) return;

  const baseWpm = 150;
  const wpm = baseWpm * state.reading.speed;
  const msPerWord = Math.max(180, Math.round(60000 / wpm));

  let idx = 0;
  state.reading.timer = setInterval(()=>{
    if(!state.reading.isPlaying) return;
    // Listen mode: also freeze highlight while narration is paused by word popover or system pause
    if(state.reading.pausedForPopover) return;
    try{ if(("speechSynthesis" in window) && window.speechSynthesis.paused) return; }catch(e){}

    setActiveWord(idx);
    state.reading.progress = (idx+1) / n;
    updateProgressUI();

    idx++;
    if(idx >= n) finishReading();
  }, msPerWord);
}

function pauseReading(){
  // Pause narration WITHOUT advancing the cursor
  state.reading.isPlaying = false;
  btnPlay.textContent = "‚ñ∂";
  openaiStopRequested = true; // cancel any in-flight async steps
  stopAudioWordHighlight();
  try{ if(openaiAudio) openaiAudio.pause(); }catch(e){}
  // persist resume cursor per mode
  const mode = state.route?.name;
  if(mode === "bireader"){
    state.reading.resumeIndexBi = Number.isFinite(openaiLineIndex) ? openaiLineIndex : (Number.isFinite(state.reading.activeBiLineIndex)?state.reading.activeBiLineIndex:0);
  }else{
    state.reading.resumeIndexReader = Number.isFinite(openaiLineIndex) ? openaiLineIndex : (Number.isFinite(state.reading.activeParaIndex)?state.reading.activeParaIndex:0);
  }
  saveReadingProgress();
}

function resumeReading(){
  // Resume by restarting OpenAI loop from saved cursor (reliable on Safari)
  if(!state.book) return;
  startReadingOpenAI();
}

function stopReading(){
  try{
    // remember last position per mode
    try{
      const mode = state.route?.name;
      if(mode === 'bireader'){
        if(Number.isFinite(openaiLineIndex)) state.reading.resumeIndexBi = openaiLineIndex;
      }else if(mode === 'reader'){
        if(Number.isFinite(openaiLineIndex)) state.reading.resumeIndexReader = openaiLineIndex;
      }
    }catch(e){}
saveReadingProgress(); if(state.reading._browserCancel) state.reading._browserCancel(); }catch(e){}
  state.reading._browserCancel = null;
  clearActiveLineUI();
  try{ if(lineObserver) lineObserver.disconnect(); }catch(e){}
  try{ if(biProgressObserver) biProgressObserver.disconnect(); }catch(e){}
  lineObserver = null;
  biProgressObserver = null;

  state.reading.isPlaying = false;
  btnPlay.textContent = "‚ñ∂";

  if(state.reading.timer) clearInterval(state.reading.timer);
  state.reading.timer = null;

  clearActiveWord();
  state.reading.progress = 0;
  updateProgressUI();

  if("speechSynthesis" in window) window.speechSynthesis.cancel();

  stopAudioWordHighlight();

  openaiStopRequested = true;
  try{ if(openaiAudio){ openaiAudio.pause(); openaiAudio.src = ""; } }catch(e){}
  openaiAudio = null;
}

function finishReading(){
  try{ if(state.reading._browserCancel) state.reading._browserCancel(); }catch(e){}
  state.reading._browserCancel = null;
  clearActiveLineUI();

  state.reading.isPlaying = false;
  btnPlay.textContent = "‚ñ∂";

  if(state.reading.timer) clearInterval(state.reading.timer);
  state.reading.timer = null;

  state.reading.progress = 1;
  updateProgressUI();

  if("speechSynthesis" in window) window.speechSynthesis.cancel();

  openaiStopRequested = true;
  try{ if(openaiAudio){ openaiAudio.pause(); openaiAudio.src = ""; } }catch(e){}
  openaiAudio = null;
}


function clearActiveWord(){
  const prev = state.reading.activeTokenIndex;
  if(prev >= 0 && state.reading.tokenMap[prev]){
    state.reading.tokenMap[prev].classList.remove("active");
  }
  state.reading.activeTokenIndex = -1;
}

function setActiveWord(idx){
  if(!state.reading.highlight) return;
  if(idx === state.reading.activeTokenIndex) return;

  const prev = state.reading.activeTokenIndex;
  if(prev >= 0 && state.reading.tokenMap[prev]){
    state.reading.tokenMap[prev].classList.remove("active");
  }

  const sp = state.reading.tokenMap[idx];
  if(sp){
    sp.classList.add("active");
    state.reading.activeTokenIndex = idx;

    // gentle scroll
    const r = sp.getBoundingClientRect();
    const topZone = window.innerHeight * 0.25;
    const botZone = window.innerHeight * 0.75;
    if(r.top < topZone || r.bottom > botZone){
      window.scrollBy({top: (r.top - window.innerHeight/2), behavior:"smooth"});
    }
  }
}

/* ---------------------------
   Progress UI
--------------------------- */
function updateProgressUI(){
  const pct = Math.round((state.reading.progress || 0) * 100);
  pPct.textContent = pct + "%";
  pFill.style.width = pct + "%";
}

/* ---------------------------
   Settings UI
--------------------------- */
function toggleUI(el, on){ el.classList.toggle("on", !!on); }
function showBackdrop(on){
  if(!sheetBackdrop) return;
  sheetBackdrop.style.display = on ? 'block' : 'none';
  sheetBackdrop.setAttribute('aria-hidden', on ? 'false' : 'true');
}

function openSheet(el){
  if(!el) return;
  el.style.display = 'block';
  requestAnimationFrame(()=>{ el.classList.add('open'); });
  showBackdrop(true);
}

function closeSheet(el){
  if(!el) return;
  el.classList.remove('open');
  // wait for transition
  setTimeout(()=>{
    el.style.display = 'none';
    el.setAttribute('aria-hidden','true');
    // hide backdrop only if nothing else is open
    const anyOpen = (settings && settings.classList.contains('open')) || (devPanel && devPanel.classList.contains('open')) || (chaptersSheet && chaptersSheet.classList.contains('open'));
    if(!anyOpen) showBackdrop(false);
  }, 220);
}

let currentSettingsTab = 'read';
function setSettingsTab(tab){
  currentSettingsTab = (tab==='listen') ? 'listen' : 'read';
  if(setTabRead){
    setTabRead.classList.toggle('active', currentSettingsTab==='read');
    setTabRead.setAttribute('aria-selected', currentSettingsTab==='read' ? 'true' : 'false');
  }
  if(setTabListen){
    setTabListen.classList.toggle('active', currentSettingsTab==='listen');
    setTabListen.setAttribute('aria-selected', currentSettingsTab==='listen' ? 'true' : 'false');
  }
  if(setPaneRead) setPaneRead.style.display = currentSettingsTab==='read' ? 'block' : 'none';
  if(setPaneListen) setPaneListen.style.display = currentSettingsTab==='listen' ? 'block' : 'none';
  syncSettingsUI();
}

function openSettings(){
  // never show Settings and Dev panel together
  try{ closeDev(); }catch(e){}
  setSettingsTab(currentSettingsTab);
  syncSettingsUI();
  settings.setAttribute('aria-hidden','false');
  openSheet(settings);
}
function closeSettings(){
  closeSheet(settings);
}
function syncSettingsUI(){
  targetLangSelect.value = state.reading.targetLang;
  speed.value = String(state.reading.speed);
  speedLabel.textContent = state.reading.speed.toFixed(2) + "√ó";
  // Listen tab helpers
  try{
    // gender buttons
    if(uMale && uFemale){
      uMale.classList.toggle("active", state.dev.ttsGender === "male");
      uFemale.classList.toggle("active", state.dev.ttsGender === "female");
    }

    // speed presets: keep initial speed as "Normal (100)"
    if(state.reading.normalSpeed == null){
      state.reading.normalSpeed = Number(state.reading.speed)||0.7;
    }
    const normal = Number(state.reading.normalSpeed)||0.7;
    const slowV = Math.max(0.3, normal * 0.80);
    const fastV = Math.min(2.0, normal * 1.25);

    const cur = Number(state.reading.speed)||normal;
    const dSlow = Math.abs(cur - slowV);
    const dNorm = Math.abs(cur - normal);
    const dFast = Math.abs(cur - fastV);
    const which = (dSlow<=dNorm && dSlow<=dFast) ? "slow" : (dFast<=dNorm && dFast<=dSlow) ? "fast" : "normal";
    if(uSpeedSlow && uSpeedNormal && uSpeedFast){
      uSpeedSlow.classList.toggle("active", which==="slow");
      uSpeedNormal.classList.toggle("active", which==="normal");
      uSpeedFast.classList.toggle("active", which==="fast");
    }
  }catch(e){}
  toggleUI(tTranslation, state.reading.showTranslation);
  toggleUI(tNight, state.reading.night);
  toggleUI(tHighlight, state.reading.highlight);
  setTheme(state.reading.night);
  applyHighlightTheme();
  // mode-specific settings
  const isBi = state.route?.name === "bireader";

  if(rowTapTranslate) rowTapTranslate.style.display = isBi ? "none" : "flex";
  if(rowLineTranslate) rowLineTranslate.style.display = isBi ? "flex" : "none";

  if(tLineTranslation){
    toggleUI(tLineTranslation, state.reading.lineTranslation);
  }

  document.body.classList.toggle("hideLineTrans", isBi && !state.reading.lineTranslation);
}

function openDev(){
  if(!state.dev.enabled) return;
  // never show Settings and Dev panel together
  try{ closeSettings(); }catch(e){}
  syncDevUI();
  devPanel.setAttribute('aria-hidden','false');
  openSheet(devPanel);
}
function closeDev(){
  closeSheet(devPanel);
}
function setSegActive(btnA, btnB, isA){
  btnA.classList.toggle("active", !!isA);
  btnB.classList.toggle("active", !isA);
}
function syncDevUI(){
  setSegActive(provOpenAI, provLibre, state.dev.translationProvider === "openai");
  setSegActive(vMale, vFemale, state.dev.ttsGender === "male");
  toggleUI(tNoCache, !!state.dev.noCache);
  toggleUI(tSwap, !!state.reading.swapLang);

  ttsVoiceSelect.innerHTML = "";
  const gender = state.dev.ttsGender;
  const list = OPENAI_TTS_VOICES.filter(v=>v.gender===gender).map(v=>v.id);
  const other = OPENAI_TTS_VOICES.filter(v=>v.gender!==gender).map(v=>v.id);
  const all = [...list, ...other];
  all.forEach(id=>{
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = id;
    ttsVoiceSelect.appendChild(opt);
  });
  ttsVoiceSelect.value = state.dev.ttsVoice;
  ttsInstructions.value = state.dev.ttsInstructions || "";

}

/* ---------------------------
   Controls
--------------------------- */
btnPlay.onclick = ()=>{
  if(!state.book) return;
  if(!state.reading.isPlaying){
    startReading();
  }else{
    pauseReading();
  }
};
btnBack.onclick = appBack;
if(btnChapters) btnChapters.onclick = (e)=>{ try{ e.preventDefault(); e.stopPropagation(); }catch(_){} openChapters(); };

btnStart.onclick = ()=>{
  // jump to the beginning for current mode
  stopReading();
  if(state.route?.name==="reader"){
    openaiLineIndex = 0;
    state.reading.resumeIndexReader = 0;
    state.reading.activeParaIndex = 0;
    setActivePara(0);
    const total = Number(state.book?.text?.length||0);
    state.reading.progress = total>0 ? 1/total : 0;
    updateProgressUI();
    saveReadingProgress();
    window.scrollTo({top:0, behavior:"smooth"});
  }else if(state.route?.name==="bireader"){
    openaiLineIndex = 0;
    state.reading.resumeIndexBi = 0;
        // sync from Reader progress if BiReader has no saved state
        try{
          const __o = sessionStorage.getItem(progressKey(bookId, "reader"));
          if(__o){
            const __p = JSON.parse(__o);
            const __idx = Number(__p.activeParaIndex||__p.resumeIndex||0);
            state.reading.activeBiLineIndex = __idx;
            state.reading.resumeIndexBi = __idx;
          }
        }catch(e){}
        // sync from Reader progress if BiReader has no saved state
        try{
          const __o = sessionStorage.getItem(progressKey(bookId, "reader"));
          if(__o){
            const __p = JSON.parse(__o);
            const __idx = Number(__p.activeParaIndex || __p.resumeIndex || 0);
            state.reading.activeBiLineIndex = __idx;
            state.reading.resumeIndexBi = __idx;
          }
        }catch(e){}
        // sync from Reader progress if BiReader has no saved state
        try{
          const __o = sessionStorage.getItem(progressKey(bookId, "reader"));
          if(__o){
            const __p = JSON.parse(__o);
            const __idx = Number(__p.activeParaIndex||__p.resumeIndex||0);
            state.reading.activeBiLineIndex = __idx;
            state.reading.resumeIndexBi = __idx;
          }
        }catch(e){}
    state.reading.activeBiLineIndex = 0;
    if(state.reading.highlight){
      setActiveLineUI(0);
    }else{
      clearActiveLineUI();
    }
    const total = Number(state.reading.biTotal||state.book?.text?.length||0);
    state.reading.progress = total>0 ? 1/total : 0;
    updateProgressUI();
    saveReadingProgress();
    window.scrollTo({top:0, behavior:"smooth"});
  }
};


if(modeListen){
  modeListen.onclick = ()=>{
    if(!state.book) return;
    if(state.route?.name==="reader") return;
    go({name:"reader", bookId: state.book.id || state.book.bookId || state.route?.bookId}, {push:false});
  };
}
if(modeRead){
  modeRead.onclick = ()=>{
    if(!state.book) return;
    if(state.route?.name==="bireader") return;
    go({name:"bireader", bookId: state.book.id || state.book.bookId || state.route?.bookId}, {push:false});
  };
}

if(devClose) devClose.onclick = closeDev;

provLibre.onclick = ()=>{ state.dev.translationProvider = "libre"; state.reading.translateCache.clear(); syncDevUI(); };
provOpenAI.onclick = ()=>{ state.dev.translationProvider = "openai"; state.reading.translateCache.clear(); syncDevUI(); };

vMale.onclick = ()=>{ state.dev.ttsGender = "male"; state.dev.ttsVoice = "onyx"; syncDevUI(); };
vFemale.onclick = ()=>{ state.dev.ttsGender = "female"; state.dev.ttsVoice = "shimmer"; syncDevUI(); };

ttsVoiceSelect.onchange = ()=>{ state.dev.ttsVoice = ttsVoiceSelect.value; };

tSwap.onclick = ()=>{ state.reading.swapLang = !state.reading.swapLang; toggleUI(tSwap, state.reading.swapLang); if(state.route?.name==="bireader"){ document.body.classList.toggle("swapLang", !!state.reading.swapLang); setActiveLineUI(state.reading.activeBiLineIndex||0); } };

tNoCache.onclick = ()=>{ state.dev.noCache = !state.dev.noCache; toggleUI(tNoCache, state.dev.noCache); };

ttsInstructions.oninput = ()=>{ state.dev.ttsInstructions = ttsInstructions.value; };

async function workerClear(url, kind){
  url = String(url||"").trim();
  if(!url) return alert("Worker URL –Ω–µ –∑–∞–¥–∞–Ω–æ");
  const res = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({action:"clear", kind})}).catch(()=>null);
  if(!res) return alert("–ù–µ –≤–¥–∞–ª–æ—Å—è –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è");
  if(!res.ok) return alert("–ü–æ–º–∏–ª–∫–∞ –æ—á–∏—Å—Ç–∫–∏: " + res.status);
  alert("OK: cache cleared");
}
btnClearTr.onclick = ()=>workerClear(WORKER_TRANSLATE_URL, "translate");
btnClearTts.onclick = ()=>workerClear(WORKER_TTS_URL, "tts");
setClose.onclick = closeSettings;
if(chaptersClose) chaptersClose.onclick = closeChapters;

// Sheet interactions
if(sheetBackdrop){
  sheetBackdrop.onclick = ()=>{
    if(settings && settings.classList.contains('open')) closeSettings();
    if(devPanel && devPanel.classList.contains('open')) closeDev();
    if(chaptersSheet && chaptersSheet.classList.contains('open')) closeChapters();
  };
}

if(setTabRead) setTabRead.onclick = ()=>setSettingsTab('read');
if(setTabListen) setTabListen.onclick = ()=>setSettingsTab('listen');

// User voice gender (duplicate of admin)
if(uMale) uMale.onclick = ()=>{ state.dev.ttsGender='male'; state.dev.ttsVoice='onyx'; syncDevUI(); syncSettingsUI(); };
if(uFemale) uFemale.onclick = ()=>{ state.dev.ttsGender='female'; state.dev.ttsVoice='shimmer'; syncDevUI(); syncSettingsUI(); };

// User speed presets (fixed values)
const SPEED_PRESETS = { slow: 0.8, normal: 1.0, fast: 1.25 };
function setSpeedPreset(kind){
  const v = SPEED_PRESETS[kind] ?? 1.0;
  state.reading.speed = v;
  speed.value = String(v);
  speedLabel.textContent = v.toFixed(2) + '√ó';
  // Update UI immediately (no need to close the sheet)
  if(uSpeedSlow && uSpeedNormal && uSpeedFast){
    uSpeedSlow.classList.toggle('active', kind==='slow');
    uSpeedNormal.classList.toggle('active', kind==='normal');
    uSpeedFast.classList.toggle('active', kind==='fast');
  }
  try{ syncSettingsUI(); }catch(e){}
  if(state.reading.isPlaying) startReading();
}
if(uSpeedSlow) uSpeedSlow.onclick = ()=>setSpeedPreset('slow');
if(uSpeedNormal) uSpeedNormal.onclick = ()=>setSpeedPreset('normal');
if(uSpeedFast) uSpeedFast.onclick = ()=>setSpeedPreset('fast');

fontMinus.onclick = ()=>{
  state.reading.fontSize = Math.max(16, state.reading.fontSize - 2);
  document.documentElement.style.setProperty("--fontSize", state.reading.fontSize + "px");
};
fontPlus.onclick = ()=>{
  state.reading.fontSize = Math.min(34, state.reading.fontSize + 2);
  document.documentElement.style.setProperty("--fontSize", state.reading.fontSize + "px");
};

speed.oninput = ()=>{
  state.reading.speed = Number(speed.value);
  speedLabel.textContent = state.reading.speed.toFixed(2) + "√ó";
  try{ syncSettingsUI(); }catch(e){}
  if(state.reading.isPlaying) startReading();
};

hlDefault.onclick = ()=>{
  state.reading.highlightTheme = "default";
  applyHighlightTheme();
};
hlYellow.onclick = ()=>{
  state.reading.highlightTheme = "yellow";
  applyHighlightTheme();
};

tTranslation.onclick = ()=>{
  state.reading.showTranslation = !state.reading.showTranslation;
  toggleUI(tTranslation, state.reading.showTranslation);
  if(!state.reading.showTranslation) hideTranslation();
};

tLineTranslation.onclick = ()=>{
  state.reading.lineTranslation = !state.reading.lineTranslation;
  toggleUI(tLineTranslation, state.reading.lineTranslation);

  const isBi = state.route?.name === "bireader";
  if(isBi){
    document.body.classList.toggle("hideLineTrans", !state.reading.lineTranslation);
    if(state.reading.lineTranslation) initLineTranslations();
  }
};

tNight.onclick = ()=>{
  state.reading.night = !state.reading.night;
  toggleUI(tNight, state.reading.night);
  setTheme(state.reading.night);
  applyHighlightTheme();
};
tHighlight.onclick = ()=>{
  state.reading.highlight = !state.reading.highlight;
  toggleUI(tHighlight, state.reading.highlight);

  if(!state.reading.highlight){
    clearActiveWord();
    clearActivePara();
    clearActiveLineUI();
  }else{
    // Re-apply current highlight if we have a known index
    const mode = state.route?.name;
    if(mode === "reader"){
      if(state.reading.activeParaIndex != null && state.reading.activeParaIndex >= 0){
        setActivePara(state.reading.activeParaIndex);
      }
    }
    if(mode === "bireader"){
      if(typeof openaiLineIndex === "number"){
        setActiveLineUI(openaiLineIndex);
      }
    }
  }
};

targetLangSelect.onchange = ()=>{
  // Save current progress for OLD pair, then switch and restore for NEW pair
  try{ saveReadingProgress(); }catch(e){}
  state.reading.targetLang = targetLangSelect.value;
  try{ state.reading.translateCache.clear(); }catch(e){}
  document.querySelectorAll(".paraTrans").forEach(el=>{
    el.textContent = "";
    el.dataset.done = "0";
  });

  applyLanguagePairChange();

  if(state.route?.name === 'bireader' && state.reading.lineTranslation){
    refreshBiReaderTranslations();
  }
  if(state.route?.name === 'reader' && state.reading.lineTranslation){
    attachLineTranslationObserver();
  }
};

// close settings on outside click
document.addEventListener("click", (e)=>{
  if(settings.style.display !== "block") return;
  // ignore the same click that opened the sheet
  try{ if(e.target && e.target.closest && e.target.closest('#topSettings')) return; }catch(_e){}
  if(settings.contains(e.target)) return;
  closeSettings();
});

/* ---------------------------
   Init
--------------------------- */
(function init(){
  TARGET_LANGS.forEach(l=>{
    const opt = document.createElement("option");
    opt.value = l.code;
    opt.textContent = l.label;
    targetLangSelect.appendChild(opt);
  });
  targetLangSelect.value = state.reading.targetLang;

  loadCatalog().then(()=>go({name:"catalog"}, {push:false}));
})();
</script>
</body>
</html>
